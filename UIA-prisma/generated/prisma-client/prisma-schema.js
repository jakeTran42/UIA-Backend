module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBoss {
  count: Int!
}

type AggregateBossStruct {
  count: Int!
}

type AggregateClass {
  count: Int!
}

type AggregateConnectContinent {
  count: Int!
}

type AggregateConnectedMap {
  count: Int!
}

type AggregateContinent {
  count: Int!
}

type AggregateElement {
  count: Int!
}

type AggregateGuide {
  count: Int!
}

type AggregateMap {
  count: Int!
}

type AggregateMonsterSkill {
  count: Int!
}

type AggregateSkill {
  count: Int!
}

type AggregateStageStruct {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Boss {
  id: ID!
  name: String!
  element_one: Element
  element_one_value: Int
  element_two: Element
  element_two_value: Int
  locations_found(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map!]
  continent_found(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Continent!]
}

type BossConnection {
  pageInfo: PageInfo!
  edges: [BossEdge]!
  aggregate: AggregateBoss!
}

input BossCreateInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  locations_found: MapCreateManyWithoutNative_bossInput
  continent_found: ContinentCreateManyWithoutBossesInput
}

input BossCreateManyWithoutContinent_foundInput {
  create: [BossCreateWithoutContinent_foundInput!]
  connect: [BossWhereUniqueInput!]
}

input BossCreateManyWithoutLocations_foundInput {
  create: [BossCreateWithoutLocations_foundInput!]
  connect: [BossWhereUniqueInput!]
}

input BossCreateOneInput {
  create: BossCreateInput
  connect: BossWhereUniqueInput
}

input BossCreateWithoutContinent_foundInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  locations_found: MapCreateManyWithoutNative_bossInput
}

input BossCreateWithoutLocations_foundInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  continent_found: ContinentCreateManyWithoutBossesInput
}

type BossEdge {
  node: Boss!
  cursor: String!
}

enum BossOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  element_one_value_ASC
  element_one_value_DESC
  element_two_value_ASC
  element_two_value_DESC
}

type BossPreviousValues {
  id: ID!
  name: String!
  element_one_value: Int
  element_two_value: Int
}

input BossScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  element_one_value: Int
  element_one_value_not: Int
  element_one_value_in: [Int!]
  element_one_value_not_in: [Int!]
  element_one_value_lt: Int
  element_one_value_lte: Int
  element_one_value_gt: Int
  element_one_value_gte: Int
  element_two_value: Int
  element_two_value_not: Int
  element_two_value_in: [Int!]
  element_two_value_not_in: [Int!]
  element_two_value_lt: Int
  element_two_value_lte: Int
  element_two_value_gt: Int
  element_two_value_gte: Int
  AND: [BossScalarWhereInput!]
  OR: [BossScalarWhereInput!]
  NOT: [BossScalarWhereInput!]
}

type BossStruct {
  id: ID!
  createdAt: DateTime!
  monster_found: Boss!
  minion_present: Boolean
  location: StageStruct
  HP: Int!
  ATK: Int!
  Armor: Int!
  AtkSpd: Float!
  skills(where: MonsterSkillWhereInput, orderBy: MonsterSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MonsterSkill!]
}

type BossStructConnection {
  pageInfo: PageInfo!
  edges: [BossStructEdge]!
  aggregate: AggregateBossStruct!
}

input BossStructCreateInput {
  id: ID
  monster_found: BossCreateOneInput!
  minion_present: Boolean
  location: StageStructCreateOneWithoutBoss_foundInput
  HP: Int!
  ATK: Int!
  Armor: Int!
  AtkSpd: Float!
  skills: MonsterSkillCreateManyInput
}

input BossStructCreateManyInput {
  create: [BossStructCreateInput!]
  connect: [BossStructWhereUniqueInput!]
}

input BossStructCreateOneWithoutLocationInput {
  create: BossStructCreateWithoutLocationInput
  connect: BossStructWhereUniqueInput
}

input BossStructCreateWithoutLocationInput {
  id: ID
  monster_found: BossCreateOneInput!
  minion_present: Boolean
  HP: Int!
  ATK: Int!
  Armor: Int!
  AtkSpd: Float!
  skills: MonsterSkillCreateManyInput
}

type BossStructEdge {
  node: BossStruct!
  cursor: String!
}

enum BossStructOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  minion_present_ASC
  minion_present_DESC
  HP_ASC
  HP_DESC
  ATK_ASC
  ATK_DESC
  Armor_ASC
  Armor_DESC
  AtkSpd_ASC
  AtkSpd_DESC
}

type BossStructPreviousValues {
  id: ID!
  createdAt: DateTime!
  minion_present: Boolean
  HP: Int!
  ATK: Int!
  Armor: Int!
  AtkSpd: Float!
}

input BossStructScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  minion_present: Boolean
  minion_present_not: Boolean
  HP: Int
  HP_not: Int
  HP_in: [Int!]
  HP_not_in: [Int!]
  HP_lt: Int
  HP_lte: Int
  HP_gt: Int
  HP_gte: Int
  ATK: Int
  ATK_not: Int
  ATK_in: [Int!]
  ATK_not_in: [Int!]
  ATK_lt: Int
  ATK_lte: Int
  ATK_gt: Int
  ATK_gte: Int
  Armor: Int
  Armor_not: Int
  Armor_in: [Int!]
  Armor_not_in: [Int!]
  Armor_lt: Int
  Armor_lte: Int
  Armor_gt: Int
  Armor_gte: Int
  AtkSpd: Float
  AtkSpd_not: Float
  AtkSpd_in: [Float!]
  AtkSpd_not_in: [Float!]
  AtkSpd_lt: Float
  AtkSpd_lte: Float
  AtkSpd_gt: Float
  AtkSpd_gte: Float
  AND: [BossStructScalarWhereInput!]
  OR: [BossStructScalarWhereInput!]
  NOT: [BossStructScalarWhereInput!]
}

type BossStructSubscriptionPayload {
  mutation: MutationType!
  node: BossStruct
  updatedFields: [String!]
  previousValues: BossStructPreviousValues
}

input BossStructSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BossStructWhereInput
  AND: [BossStructSubscriptionWhereInput!]
  OR: [BossStructSubscriptionWhereInput!]
  NOT: [BossStructSubscriptionWhereInput!]
}

input BossStructUpdateDataInput {
  monster_found: BossUpdateOneRequiredInput
  minion_present: Boolean
  location: StageStructUpdateOneWithoutBoss_foundInput
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Float
  skills: MonsterSkillUpdateManyInput
}

input BossStructUpdateInput {
  monster_found: BossUpdateOneRequiredInput
  minion_present: Boolean
  location: StageStructUpdateOneWithoutBoss_foundInput
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Float
  skills: MonsterSkillUpdateManyInput
}

input BossStructUpdateManyDataInput {
  minion_present: Boolean
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Float
}

input BossStructUpdateManyInput {
  create: [BossStructCreateInput!]
  update: [BossStructUpdateWithWhereUniqueNestedInput!]
  upsert: [BossStructUpsertWithWhereUniqueNestedInput!]
  delete: [BossStructWhereUniqueInput!]
  connect: [BossStructWhereUniqueInput!]
  set: [BossStructWhereUniqueInput!]
  disconnect: [BossStructWhereUniqueInput!]
  deleteMany: [BossStructScalarWhereInput!]
  updateMany: [BossStructUpdateManyWithWhereNestedInput!]
}

input BossStructUpdateManyMutationInput {
  minion_present: Boolean
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Float
}

input BossStructUpdateManyWithWhereNestedInput {
  where: BossStructScalarWhereInput!
  data: BossStructUpdateManyDataInput!
}

input BossStructUpdateOneWithoutLocationInput {
  create: BossStructCreateWithoutLocationInput
  update: BossStructUpdateWithoutLocationDataInput
  upsert: BossStructUpsertWithoutLocationInput
  delete: Boolean
  disconnect: Boolean
  connect: BossStructWhereUniqueInput
}

input BossStructUpdateWithoutLocationDataInput {
  monster_found: BossUpdateOneRequiredInput
  minion_present: Boolean
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Float
  skills: MonsterSkillUpdateManyInput
}

input BossStructUpdateWithWhereUniqueNestedInput {
  where: BossStructWhereUniqueInput!
  data: BossStructUpdateDataInput!
}

input BossStructUpsertWithoutLocationInput {
  update: BossStructUpdateWithoutLocationDataInput!
  create: BossStructCreateWithoutLocationInput!
}

input BossStructUpsertWithWhereUniqueNestedInput {
  where: BossStructWhereUniqueInput!
  update: BossStructUpdateDataInput!
  create: BossStructCreateInput!
}

input BossStructWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  monster_found: BossWhereInput
  minion_present: Boolean
  minion_present_not: Boolean
  location: StageStructWhereInput
  HP: Int
  HP_not: Int
  HP_in: [Int!]
  HP_not_in: [Int!]
  HP_lt: Int
  HP_lte: Int
  HP_gt: Int
  HP_gte: Int
  ATK: Int
  ATK_not: Int
  ATK_in: [Int!]
  ATK_not_in: [Int!]
  ATK_lt: Int
  ATK_lte: Int
  ATK_gt: Int
  ATK_gte: Int
  Armor: Int
  Armor_not: Int
  Armor_in: [Int!]
  Armor_not_in: [Int!]
  Armor_lt: Int
  Armor_lte: Int
  Armor_gt: Int
  Armor_gte: Int
  AtkSpd: Float
  AtkSpd_not: Float
  AtkSpd_in: [Float!]
  AtkSpd_not_in: [Float!]
  AtkSpd_lt: Float
  AtkSpd_lte: Float
  AtkSpd_gt: Float
  AtkSpd_gte: Float
  skills_every: MonsterSkillWhereInput
  skills_some: MonsterSkillWhereInput
  skills_none: MonsterSkillWhereInput
  AND: [BossStructWhereInput!]
  OR: [BossStructWhereInput!]
  NOT: [BossStructWhereInput!]
}

input BossStructWhereUniqueInput {
  id: ID
}

type BossSubscriptionPayload {
  mutation: MutationType!
  node: Boss
  updatedFields: [String!]
  previousValues: BossPreviousValues
}

input BossSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BossWhereInput
  AND: [BossSubscriptionWhereInput!]
  OR: [BossSubscriptionWhereInput!]
  NOT: [BossSubscriptionWhereInput!]
}

input BossUpdateDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  locations_found: MapUpdateManyWithoutNative_bossInput
  continent_found: ContinentUpdateManyWithoutBossesInput
}

input BossUpdateInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  locations_found: MapUpdateManyWithoutNative_bossInput
  continent_found: ContinentUpdateManyWithoutBossesInput
}

input BossUpdateManyDataInput {
  name: String
  element_one_value: Int
  element_two_value: Int
}

input BossUpdateManyMutationInput {
  name: String
  element_one_value: Int
  element_two_value: Int
}

input BossUpdateManyWithoutContinent_foundInput {
  create: [BossCreateWithoutContinent_foundInput!]
  delete: [BossWhereUniqueInput!]
  connect: [BossWhereUniqueInput!]
  set: [BossWhereUniqueInput!]
  disconnect: [BossWhereUniqueInput!]
  update: [BossUpdateWithWhereUniqueWithoutContinent_foundInput!]
  upsert: [BossUpsertWithWhereUniqueWithoutContinent_foundInput!]
  deleteMany: [BossScalarWhereInput!]
  updateMany: [BossUpdateManyWithWhereNestedInput!]
}

input BossUpdateManyWithoutLocations_foundInput {
  create: [BossCreateWithoutLocations_foundInput!]
  delete: [BossWhereUniqueInput!]
  connect: [BossWhereUniqueInput!]
  set: [BossWhereUniqueInput!]
  disconnect: [BossWhereUniqueInput!]
  update: [BossUpdateWithWhereUniqueWithoutLocations_foundInput!]
  upsert: [BossUpsertWithWhereUniqueWithoutLocations_foundInput!]
  deleteMany: [BossScalarWhereInput!]
  updateMany: [BossUpdateManyWithWhereNestedInput!]
}

input BossUpdateManyWithWhereNestedInput {
  where: BossScalarWhereInput!
  data: BossUpdateManyDataInput!
}

input BossUpdateOneRequiredInput {
  create: BossCreateInput
  update: BossUpdateDataInput
  upsert: BossUpsertNestedInput
  connect: BossWhereUniqueInput
}

input BossUpdateWithoutContinent_foundDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  locations_found: MapUpdateManyWithoutNative_bossInput
}

input BossUpdateWithoutLocations_foundDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  continent_found: ContinentUpdateManyWithoutBossesInput
}

input BossUpdateWithWhereUniqueWithoutContinent_foundInput {
  where: BossWhereUniqueInput!
  data: BossUpdateWithoutContinent_foundDataInput!
}

input BossUpdateWithWhereUniqueWithoutLocations_foundInput {
  where: BossWhereUniqueInput!
  data: BossUpdateWithoutLocations_foundDataInput!
}

input BossUpsertNestedInput {
  update: BossUpdateDataInput!
  create: BossCreateInput!
}

input BossUpsertWithWhereUniqueWithoutContinent_foundInput {
  where: BossWhereUniqueInput!
  update: BossUpdateWithoutContinent_foundDataInput!
  create: BossCreateWithoutContinent_foundInput!
}

input BossUpsertWithWhereUniqueWithoutLocations_foundInput {
  where: BossWhereUniqueInput!
  update: BossUpdateWithoutLocations_foundDataInput!
  create: BossCreateWithoutLocations_foundInput!
}

input BossWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  element_one: ElementWhereInput
  element_one_value: Int
  element_one_value_not: Int
  element_one_value_in: [Int!]
  element_one_value_not_in: [Int!]
  element_one_value_lt: Int
  element_one_value_lte: Int
  element_one_value_gt: Int
  element_one_value_gte: Int
  element_two: ElementWhereInput
  element_two_value: Int
  element_two_value_not: Int
  element_two_value_in: [Int!]
  element_two_value_not_in: [Int!]
  element_two_value_lt: Int
  element_two_value_lte: Int
  element_two_value_gt: Int
  element_two_value_gte: Int
  locations_found_every: MapWhereInput
  locations_found_some: MapWhereInput
  locations_found_none: MapWhereInput
  continent_found_every: ContinentWhereInput
  continent_found_some: ContinentWhereInput
  continent_found_none: ContinentWhereInput
  AND: [BossWhereInput!]
  OR: [BossWhereInput!]
  NOT: [BossWhereInput!]
}

input BossWhereUniqueInput {
  id: ID
  name: String
}

type Class {
  id: ID!
  name: Hero!
  description: String!
  weapon: String!
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
}

type ClassConnection {
  pageInfo: PageInfo!
  edges: [ClassEdge]!
  aggregate: AggregateClass!
}

input ClassCreateInput {
  id: ID
  name: Hero!
  description: String!
  weapon: String!
  skills: SkillCreateManyWithoutClassInput
}

input ClassCreateOneWithoutSkillsInput {
  create: ClassCreateWithoutSkillsInput
  connect: ClassWhereUniqueInput
}

input ClassCreateWithoutSkillsInput {
  id: ID
  name: Hero!
  description: String!
  weapon: String!
}

type ClassEdge {
  node: Class!
  cursor: String!
}

enum ClassOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  weapon_ASC
  weapon_DESC
}

type ClassPreviousValues {
  id: ID!
  name: Hero!
  description: String!
  weapon: String!
}

type ClassSubscriptionPayload {
  mutation: MutationType!
  node: Class
  updatedFields: [String!]
  previousValues: ClassPreviousValues
}

input ClassSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassWhereInput
  AND: [ClassSubscriptionWhereInput!]
  OR: [ClassSubscriptionWhereInput!]
  NOT: [ClassSubscriptionWhereInput!]
}

input ClassUpdateInput {
  name: Hero
  description: String
  weapon: String
  skills: SkillUpdateManyWithoutClassInput
}

input ClassUpdateManyMutationInput {
  name: Hero
  description: String
  weapon: String
}

input ClassUpdateOneWithoutSkillsInput {
  create: ClassCreateWithoutSkillsInput
  update: ClassUpdateWithoutSkillsDataInput
  upsert: ClassUpsertWithoutSkillsInput
  delete: Boolean
  disconnect: Boolean
  connect: ClassWhereUniqueInput
}

input ClassUpdateWithoutSkillsDataInput {
  name: Hero
  description: String
  weapon: String
}

input ClassUpsertWithoutSkillsInput {
  update: ClassUpdateWithoutSkillsDataInput!
  create: ClassCreateWithoutSkillsInput!
}

input ClassWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: Hero
  name_not: Hero
  name_in: [Hero!]
  name_not_in: [Hero!]
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  weapon: String
  weapon_not: String
  weapon_in: [String!]
  weapon_not_in: [String!]
  weapon_lt: String
  weapon_lte: String
  weapon_gt: String
  weapon_gte: String
  weapon_contains: String
  weapon_not_contains: String
  weapon_starts_with: String
  weapon_not_starts_with: String
  weapon_ends_with: String
  weapon_not_ends_with: String
  skills_every: SkillWhereInput
  skills_some: SkillWhereInput
  skills_none: SkillWhereInput
  AND: [ClassWhereInput!]
  OR: [ClassWhereInput!]
  NOT: [ClassWhereInput!]
}

input ClassWhereUniqueInput {
  id: ID
  name: Hero
}

enum CombatType {
  UNKNOWN
  RANGE
  MEELEE
  SELF
  TEAM
}

type ConnectContinent {
  id: ID!
  next_continent: Continent
  previous_continent: Continent
}

type ConnectContinentConnection {
  pageInfo: PageInfo!
  edges: [ConnectContinentEdge]!
  aggregate: AggregateConnectContinent!
}

input ConnectContinentCreateInput {
  id: ID
  next_continent: ContinentCreateOneInput
  previous_continent: ContinentCreateOneWithoutConnected_continentInput
}

input ConnectContinentCreateOneWithoutPrevious_continentInput {
  create: ConnectContinentCreateWithoutPrevious_continentInput
  connect: ConnectContinentWhereUniqueInput
}

input ConnectContinentCreateWithoutPrevious_continentInput {
  id: ID
  next_continent: ContinentCreateOneInput
}

type ConnectContinentEdge {
  node: ConnectContinent!
  cursor: String!
}

enum ConnectContinentOrderByInput {
  id_ASC
  id_DESC
}

type ConnectContinentPreviousValues {
  id: ID!
}

type ConnectContinentSubscriptionPayload {
  mutation: MutationType!
  node: ConnectContinent
  updatedFields: [String!]
  previousValues: ConnectContinentPreviousValues
}

input ConnectContinentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConnectContinentWhereInput
  AND: [ConnectContinentSubscriptionWhereInput!]
  OR: [ConnectContinentSubscriptionWhereInput!]
  NOT: [ConnectContinentSubscriptionWhereInput!]
}

input ConnectContinentUpdateInput {
  next_continent: ContinentUpdateOneInput
  previous_continent: ContinentUpdateOneWithoutConnected_continentInput
}

input ConnectContinentUpdateOneWithoutPrevious_continentInput {
  create: ConnectContinentCreateWithoutPrevious_continentInput
  update: ConnectContinentUpdateWithoutPrevious_continentDataInput
  upsert: ConnectContinentUpsertWithoutPrevious_continentInput
  delete: Boolean
  disconnect: Boolean
  connect: ConnectContinentWhereUniqueInput
}

input ConnectContinentUpdateWithoutPrevious_continentDataInput {
  next_continent: ContinentUpdateOneInput
}

input ConnectContinentUpsertWithoutPrevious_continentInput {
  update: ConnectContinentUpdateWithoutPrevious_continentDataInput!
  create: ConnectContinentCreateWithoutPrevious_continentInput!
}

input ConnectContinentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  next_continent: ContinentWhereInput
  previous_continent: ContinentWhereInput
  AND: [ConnectContinentWhereInput!]
  OR: [ConnectContinentWhereInput!]
  NOT: [ConnectContinentWhereInput!]
}

input ConnectContinentWhereUniqueInput {
  id: ID
}

type ConnectedMap {
  id: ID!
  next_map: Map!
  previous_map: Map!
}

type ConnectedMapConnection {
  pageInfo: PageInfo!
  edges: [ConnectedMapEdge]!
  aggregate: AggregateConnectedMap!
}

input ConnectedMapCreateInput {
  id: ID
  next_map: MapCreateOneInput!
  previous_map: MapCreateOneWithoutConnected_mapsInput!
}

input ConnectedMapCreateOneWithoutPrevious_mapInput {
  create: ConnectedMapCreateWithoutPrevious_mapInput
  connect: ConnectedMapWhereUniqueInput
}

input ConnectedMapCreateWithoutPrevious_mapInput {
  id: ID
  next_map: MapCreateOneInput!
}

type ConnectedMapEdge {
  node: ConnectedMap!
  cursor: String!
}

enum ConnectedMapOrderByInput {
  id_ASC
  id_DESC
}

type ConnectedMapPreviousValues {
  id: ID!
}

type ConnectedMapSubscriptionPayload {
  mutation: MutationType!
  node: ConnectedMap
  updatedFields: [String!]
  previousValues: ConnectedMapPreviousValues
}

input ConnectedMapSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConnectedMapWhereInput
  AND: [ConnectedMapSubscriptionWhereInput!]
  OR: [ConnectedMapSubscriptionWhereInput!]
  NOT: [ConnectedMapSubscriptionWhereInput!]
}

input ConnectedMapUpdateInput {
  next_map: MapUpdateOneRequiredInput
  previous_map: MapUpdateOneRequiredWithoutConnected_mapsInput
}

input ConnectedMapUpdateOneWithoutPrevious_mapInput {
  create: ConnectedMapCreateWithoutPrevious_mapInput
  update: ConnectedMapUpdateWithoutPrevious_mapDataInput
  upsert: ConnectedMapUpsertWithoutPrevious_mapInput
  delete: Boolean
  disconnect: Boolean
  connect: ConnectedMapWhereUniqueInput
}

input ConnectedMapUpdateWithoutPrevious_mapDataInput {
  next_map: MapUpdateOneRequiredInput
}

input ConnectedMapUpsertWithoutPrevious_mapInput {
  update: ConnectedMapUpdateWithoutPrevious_mapDataInput!
  create: ConnectedMapCreateWithoutPrevious_mapInput!
}

input ConnectedMapWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  next_map: MapWhereInput
  previous_map: MapWhereInput
  AND: [ConnectedMapWhereInput!]
  OR: [ConnectedMapWhereInput!]
  NOT: [ConnectedMapWhereInput!]
}

input ConnectedMapWhereUniqueInput {
  id: ID
}

type Continent {
  id: ID!
  name: String!
  bosses(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss!]
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map!]
  connected_continent: ConnectContinent
}

type ContinentConnection {
  pageInfo: PageInfo!
  edges: [ContinentEdge]!
  aggregate: AggregateContinent!
}

input ContinentCreateInput {
  id: ID
  name: String!
  bosses: BossCreateManyWithoutContinent_foundInput
  maps: MapCreateManyWithoutContinentInput
  connected_continent: ConnectContinentCreateOneWithoutPrevious_continentInput
}

input ContinentCreateManyWithoutBossesInput {
  create: [ContinentCreateWithoutBossesInput!]
  connect: [ContinentWhereUniqueInput!]
}

input ContinentCreateOneInput {
  create: ContinentCreateInput
  connect: ContinentWhereUniqueInput
}

input ContinentCreateOneWithoutConnected_continentInput {
  create: ContinentCreateWithoutConnected_continentInput
  connect: ContinentWhereUniqueInput
}

input ContinentCreateOneWithoutMapsInput {
  create: ContinentCreateWithoutMapsInput
  connect: ContinentWhereUniqueInput
}

input ContinentCreateWithoutBossesInput {
  id: ID
  name: String!
  maps: MapCreateManyWithoutContinentInput
  connected_continent: ConnectContinentCreateOneWithoutPrevious_continentInput
}

input ContinentCreateWithoutConnected_continentInput {
  id: ID
  name: String!
  bosses: BossCreateManyWithoutContinent_foundInput
  maps: MapCreateManyWithoutContinentInput
}

input ContinentCreateWithoutMapsInput {
  id: ID
  name: String!
  bosses: BossCreateManyWithoutContinent_foundInput
  connected_continent: ConnectContinentCreateOneWithoutPrevious_continentInput
}

type ContinentEdge {
  node: Continent!
  cursor: String!
}

enum ContinentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ContinentPreviousValues {
  id: ID!
  name: String!
}

input ContinentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ContinentScalarWhereInput!]
  OR: [ContinentScalarWhereInput!]
  NOT: [ContinentScalarWhereInput!]
}

type ContinentSubscriptionPayload {
  mutation: MutationType!
  node: Continent
  updatedFields: [String!]
  previousValues: ContinentPreviousValues
}

input ContinentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContinentWhereInput
  AND: [ContinentSubscriptionWhereInput!]
  OR: [ContinentSubscriptionWhereInput!]
  NOT: [ContinentSubscriptionWhereInput!]
}

input ContinentUpdateDataInput {
  name: String
  bosses: BossUpdateManyWithoutContinent_foundInput
  maps: MapUpdateManyWithoutContinentInput
  connected_continent: ConnectContinentUpdateOneWithoutPrevious_continentInput
}

input ContinentUpdateInput {
  name: String
  bosses: BossUpdateManyWithoutContinent_foundInput
  maps: MapUpdateManyWithoutContinentInput
  connected_continent: ConnectContinentUpdateOneWithoutPrevious_continentInput
}

input ContinentUpdateManyDataInput {
  name: String
}

input ContinentUpdateManyMutationInput {
  name: String
}

input ContinentUpdateManyWithoutBossesInput {
  create: [ContinentCreateWithoutBossesInput!]
  delete: [ContinentWhereUniqueInput!]
  connect: [ContinentWhereUniqueInput!]
  set: [ContinentWhereUniqueInput!]
  disconnect: [ContinentWhereUniqueInput!]
  update: [ContinentUpdateWithWhereUniqueWithoutBossesInput!]
  upsert: [ContinentUpsertWithWhereUniqueWithoutBossesInput!]
  deleteMany: [ContinentScalarWhereInput!]
  updateMany: [ContinentUpdateManyWithWhereNestedInput!]
}

input ContinentUpdateManyWithWhereNestedInput {
  where: ContinentScalarWhereInput!
  data: ContinentUpdateManyDataInput!
}

input ContinentUpdateOneInput {
  create: ContinentCreateInput
  update: ContinentUpdateDataInput
  upsert: ContinentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ContinentWhereUniqueInput
}

input ContinentUpdateOneRequiredWithoutMapsInput {
  create: ContinentCreateWithoutMapsInput
  update: ContinentUpdateWithoutMapsDataInput
  upsert: ContinentUpsertWithoutMapsInput
  connect: ContinentWhereUniqueInput
}

input ContinentUpdateOneWithoutConnected_continentInput {
  create: ContinentCreateWithoutConnected_continentInput
  update: ContinentUpdateWithoutConnected_continentDataInput
  upsert: ContinentUpsertWithoutConnected_continentInput
  delete: Boolean
  disconnect: Boolean
  connect: ContinentWhereUniqueInput
}

input ContinentUpdateWithoutBossesDataInput {
  name: String
  maps: MapUpdateManyWithoutContinentInput
  connected_continent: ConnectContinentUpdateOneWithoutPrevious_continentInput
}

input ContinentUpdateWithoutConnected_continentDataInput {
  name: String
  bosses: BossUpdateManyWithoutContinent_foundInput
  maps: MapUpdateManyWithoutContinentInput
}

input ContinentUpdateWithoutMapsDataInput {
  name: String
  bosses: BossUpdateManyWithoutContinent_foundInput
  connected_continent: ConnectContinentUpdateOneWithoutPrevious_continentInput
}

input ContinentUpdateWithWhereUniqueWithoutBossesInput {
  where: ContinentWhereUniqueInput!
  data: ContinentUpdateWithoutBossesDataInput!
}

input ContinentUpsertNestedInput {
  update: ContinentUpdateDataInput!
  create: ContinentCreateInput!
}

input ContinentUpsertWithoutConnected_continentInput {
  update: ContinentUpdateWithoutConnected_continentDataInput!
  create: ContinentCreateWithoutConnected_continentInput!
}

input ContinentUpsertWithoutMapsInput {
  update: ContinentUpdateWithoutMapsDataInput!
  create: ContinentCreateWithoutMapsInput!
}

input ContinentUpsertWithWhereUniqueWithoutBossesInput {
  where: ContinentWhereUniqueInput!
  update: ContinentUpdateWithoutBossesDataInput!
  create: ContinentCreateWithoutBossesInput!
}

input ContinentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bosses_every: BossWhereInput
  bosses_some: BossWhereInput
  bosses_none: BossWhereInput
  maps_every: MapWhereInput
  maps_some: MapWhereInput
  maps_none: MapWhereInput
  connected_continent: ConnectContinentWhereInput
  AND: [ContinentWhereInput!]
  OR: [ContinentWhereInput!]
  NOT: [ContinentWhereInput!]
}

input ContinentWhereUniqueInput {
  id: ID
  name: String
}

scalar DateTime

type Element {
  id: ID!
  name: ElementType!
  weakness: ElementType
  effective: ElementType
}

type ElementConnection {
  pageInfo: PageInfo!
  edges: [ElementEdge]!
  aggregate: AggregateElement!
}

input ElementCreateInput {
  id: ID
  name: ElementType!
  weakness: ElementType
  effective: ElementType
}

input ElementCreateOneInput {
  create: ElementCreateInput
  connect: ElementWhereUniqueInput
}

type ElementEdge {
  node: Element!
  cursor: String!
}

enum ElementOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  weakness_ASC
  weakness_DESC
  effective_ASC
  effective_DESC
}

type ElementPreviousValues {
  id: ID!
  name: ElementType!
  weakness: ElementType
  effective: ElementType
}

type ElementSubscriptionPayload {
  mutation: MutationType!
  node: Element
  updatedFields: [String!]
  previousValues: ElementPreviousValues
}

input ElementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ElementWhereInput
  AND: [ElementSubscriptionWhereInput!]
  OR: [ElementSubscriptionWhereInput!]
  NOT: [ElementSubscriptionWhereInput!]
}

enum ElementType {
  FIRE
  LIGHTNING
  FROST
  EARTH
}

input ElementUpdateDataInput {
  name: ElementType
  weakness: ElementType
  effective: ElementType
}

input ElementUpdateInput {
  name: ElementType
  weakness: ElementType
  effective: ElementType
}

input ElementUpdateManyMutationInput {
  name: ElementType
  weakness: ElementType
  effective: ElementType
}

input ElementUpdateOneInput {
  create: ElementCreateInput
  update: ElementUpdateDataInput
  upsert: ElementUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ElementWhereUniqueInput
}

input ElementUpsertNestedInput {
  update: ElementUpdateDataInput!
  create: ElementCreateInput!
}

input ElementWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: ElementType
  name_not: ElementType
  name_in: [ElementType!]
  name_not_in: [ElementType!]
  weakness: ElementType
  weakness_not: ElementType
  weakness_in: [ElementType!]
  weakness_not_in: [ElementType!]
  effective: ElementType
  effective_not: ElementType
  effective_in: [ElementType!]
  effective_not_in: [ElementType!]
  AND: [ElementWhereInput!]
  OR: [ElementWhereInput!]
  NOT: [ElementWhereInput!]
}

input ElementWhereUniqueInput {
  id: ID
  name: ElementType
}

type Guide {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  title: String!
  body: String!
  owner: User!
}

type GuideConnection {
  pageInfo: PageInfo!
  edges: [GuideEdge]!
  aggregate: AggregateGuide!
}

input GuideCreateInput {
  id: ID
  updateAt: DateTime
  title: String!
  body: String!
  owner: UserCreateOneWithoutGuidesInput!
}

input GuideCreateManyWithoutOwnerInput {
  create: [GuideCreateWithoutOwnerInput!]
  connect: [GuideWhereUniqueInput!]
}

input GuideCreateWithoutOwnerInput {
  id: ID
  updateAt: DateTime
  title: String!
  body: String!
}

type GuideEdge {
  node: Guide!
  cursor: String!
}

enum GuideOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updateAt_ASC
  updateAt_DESC
  title_ASC
  title_DESC
  body_ASC
  body_DESC
}

type GuidePreviousValues {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  title: String!
  body: String!
}

input GuideScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [GuideScalarWhereInput!]
  OR: [GuideScalarWhereInput!]
  NOT: [GuideScalarWhereInput!]
}

type GuideSubscriptionPayload {
  mutation: MutationType!
  node: Guide
  updatedFields: [String!]
  previousValues: GuidePreviousValues
}

input GuideSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuideWhereInput
  AND: [GuideSubscriptionWhereInput!]
  OR: [GuideSubscriptionWhereInput!]
  NOT: [GuideSubscriptionWhereInput!]
}

input GuideUpdateInput {
  updateAt: DateTime
  title: String
  body: String
  owner: UserUpdateOneRequiredWithoutGuidesInput
}

input GuideUpdateManyDataInput {
  updateAt: DateTime
  title: String
  body: String
}

input GuideUpdateManyMutationInput {
  updateAt: DateTime
  title: String
  body: String
}

input GuideUpdateManyWithoutOwnerInput {
  create: [GuideCreateWithoutOwnerInput!]
  delete: [GuideWhereUniqueInput!]
  connect: [GuideWhereUniqueInput!]
  set: [GuideWhereUniqueInput!]
  disconnect: [GuideWhereUniqueInput!]
  update: [GuideUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [GuideUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [GuideScalarWhereInput!]
  updateMany: [GuideUpdateManyWithWhereNestedInput!]
}

input GuideUpdateManyWithWhereNestedInput {
  where: GuideScalarWhereInput!
  data: GuideUpdateManyDataInput!
}

input GuideUpdateWithoutOwnerDataInput {
  updateAt: DateTime
  title: String
  body: String
}

input GuideUpdateWithWhereUniqueWithoutOwnerInput {
  where: GuideWhereUniqueInput!
  data: GuideUpdateWithoutOwnerDataInput!
}

input GuideUpsertWithWhereUniqueWithoutOwnerInput {
  where: GuideWhereUniqueInput!
  update: GuideUpdateWithoutOwnerDataInput!
  create: GuideCreateWithoutOwnerInput!
}

input GuideWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  owner: UserWhereInput
  AND: [GuideWhereInput!]
  OR: [GuideWhereInput!]
  NOT: [GuideWhereInput!]
}

input GuideWhereUniqueInput {
  id: ID
}

enum Hero {
  WARLOCK
  SHAMAN
  ASSASSIN
  HUNTER
  DRUID
  MAGE
  GLADIATOR
  WARRIOR
}

scalar Long

type Map {
  id: ID!
  name: String!
  total_stage: Int
  native_boss(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss!]
  connected_maps: ConnectedMap
  continent: Continent!
  obtainable_skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
  boss_stages(where: BossStructWhereInput, orderBy: BossStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BossStruct!]
  field_stages(where: StageStructWhereInput, orderBy: StageStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StageStruct!]
}

type MapConnection {
  pageInfo: PageInfo!
  edges: [MapEdge]!
  aggregate: AggregateMap!
}

input MapCreateInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapCreateOneWithoutPrevious_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
  obtainable_skills: SkillCreateManyWithoutLocationInput
  boss_stages: BossStructCreateManyInput
  field_stages: StageStructCreateManyWithoutMapInput
}

input MapCreateManyWithoutContinentInput {
  create: [MapCreateWithoutContinentInput!]
  connect: [MapWhereUniqueInput!]
}

input MapCreateManyWithoutNative_bossInput {
  create: [MapCreateWithoutNative_bossInput!]
  connect: [MapWhereUniqueInput!]
}

input MapCreateOneInput {
  create: MapCreateInput
  connect: MapWhereUniqueInput
}

input MapCreateOneWithoutConnected_mapsInput {
  create: MapCreateWithoutConnected_mapsInput
  connect: MapWhereUniqueInput
}

input MapCreateOneWithoutField_stagesInput {
  create: MapCreateWithoutField_stagesInput
  connect: MapWhereUniqueInput
}

input MapCreateOneWithoutObtainable_skillsInput {
  create: MapCreateWithoutObtainable_skillsInput
  connect: MapWhereUniqueInput
}

input MapCreateWithoutConnected_mapsInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutLocations_foundInput
  continent: ContinentCreateOneWithoutMapsInput!
  obtainable_skills: SkillCreateManyWithoutLocationInput
  boss_stages: BossStructCreateManyInput
  field_stages: StageStructCreateManyWithoutMapInput
}

input MapCreateWithoutContinentInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapCreateOneWithoutPrevious_mapInput
  obtainable_skills: SkillCreateManyWithoutLocationInput
  boss_stages: BossStructCreateManyInput
  field_stages: StageStructCreateManyWithoutMapInput
}

input MapCreateWithoutField_stagesInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapCreateOneWithoutPrevious_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
  obtainable_skills: SkillCreateManyWithoutLocationInput
  boss_stages: BossStructCreateManyInput
}

input MapCreateWithoutNative_bossInput {
  id: ID
  name: String!
  total_stage: Int
  connected_maps: ConnectedMapCreateOneWithoutPrevious_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
  obtainable_skills: SkillCreateManyWithoutLocationInput
  boss_stages: BossStructCreateManyInput
  field_stages: StageStructCreateManyWithoutMapInput
}

input MapCreateWithoutObtainable_skillsInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapCreateOneWithoutPrevious_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
  boss_stages: BossStructCreateManyInput
  field_stages: StageStructCreateManyWithoutMapInput
}

type MapEdge {
  node: Map!
  cursor: String!
}

enum MapOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  total_stage_ASC
  total_stage_DESC
}

type MapPreviousValues {
  id: ID!
  name: String!
  total_stage: Int
}

input MapScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  total_stage: Int
  total_stage_not: Int
  total_stage_in: [Int!]
  total_stage_not_in: [Int!]
  total_stage_lt: Int
  total_stage_lte: Int
  total_stage_gt: Int
  total_stage_gte: Int
  AND: [MapScalarWhereInput!]
  OR: [MapScalarWhereInput!]
  NOT: [MapScalarWhereInput!]
}

type MapSubscriptionPayload {
  mutation: MutationType!
  node: Map
  updatedFields: [String!]
  previousValues: MapPreviousValues
}

input MapSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MapWhereInput
  AND: [MapSubscriptionWhereInput!]
  OR: [MapSubscriptionWhereInput!]
  NOT: [MapSubscriptionWhereInput!]
}

input MapUpdateDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapUpdateOneWithoutPrevious_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  boss_stages: BossStructUpdateManyInput
  field_stages: StageStructUpdateManyWithoutMapInput
}

input MapUpdateInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapUpdateOneWithoutPrevious_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  boss_stages: BossStructUpdateManyInput
  field_stages: StageStructUpdateManyWithoutMapInput
}

input MapUpdateManyDataInput {
  name: String
  total_stage: Int
}

input MapUpdateManyMutationInput {
  name: String
  total_stage: Int
}

input MapUpdateManyWithoutContinentInput {
  create: [MapCreateWithoutContinentInput!]
  delete: [MapWhereUniqueInput!]
  connect: [MapWhereUniqueInput!]
  set: [MapWhereUniqueInput!]
  disconnect: [MapWhereUniqueInput!]
  update: [MapUpdateWithWhereUniqueWithoutContinentInput!]
  upsert: [MapUpsertWithWhereUniqueWithoutContinentInput!]
  deleteMany: [MapScalarWhereInput!]
  updateMany: [MapUpdateManyWithWhereNestedInput!]
}

input MapUpdateManyWithoutNative_bossInput {
  create: [MapCreateWithoutNative_bossInput!]
  delete: [MapWhereUniqueInput!]
  connect: [MapWhereUniqueInput!]
  set: [MapWhereUniqueInput!]
  disconnect: [MapWhereUniqueInput!]
  update: [MapUpdateWithWhereUniqueWithoutNative_bossInput!]
  upsert: [MapUpsertWithWhereUniqueWithoutNative_bossInput!]
  deleteMany: [MapScalarWhereInput!]
  updateMany: [MapUpdateManyWithWhereNestedInput!]
}

input MapUpdateManyWithWhereNestedInput {
  where: MapScalarWhereInput!
  data: MapUpdateManyDataInput!
}

input MapUpdateOneRequiredInput {
  create: MapCreateInput
  update: MapUpdateDataInput
  upsert: MapUpsertNestedInput
  connect: MapWhereUniqueInput
}

input MapUpdateOneRequiredWithoutConnected_mapsInput {
  create: MapCreateWithoutConnected_mapsInput
  update: MapUpdateWithoutConnected_mapsDataInput
  upsert: MapUpsertWithoutConnected_mapsInput
  connect: MapWhereUniqueInput
}

input MapUpdateOneRequiredWithoutField_stagesInput {
  create: MapCreateWithoutField_stagesInput
  update: MapUpdateWithoutField_stagesDataInput
  upsert: MapUpsertWithoutField_stagesInput
  connect: MapWhereUniqueInput
}

input MapUpdateOneWithoutObtainable_skillsInput {
  create: MapCreateWithoutObtainable_skillsInput
  update: MapUpdateWithoutObtainable_skillsDataInput
  upsert: MapUpsertWithoutObtainable_skillsInput
  delete: Boolean
  disconnect: Boolean
  connect: MapWhereUniqueInput
}

input MapUpdateWithoutConnected_mapsDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutLocations_foundInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  boss_stages: BossStructUpdateManyInput
  field_stages: StageStructUpdateManyWithoutMapInput
}

input MapUpdateWithoutContinentDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapUpdateOneWithoutPrevious_mapInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  boss_stages: BossStructUpdateManyInput
  field_stages: StageStructUpdateManyWithoutMapInput
}

input MapUpdateWithoutField_stagesDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapUpdateOneWithoutPrevious_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  boss_stages: BossStructUpdateManyInput
}

input MapUpdateWithoutNative_bossDataInput {
  name: String
  total_stage: Int
  connected_maps: ConnectedMapUpdateOneWithoutPrevious_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  boss_stages: BossStructUpdateManyInput
  field_stages: StageStructUpdateManyWithoutMapInput
}

input MapUpdateWithoutObtainable_skillsDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutLocations_foundInput
  connected_maps: ConnectedMapUpdateOneWithoutPrevious_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  boss_stages: BossStructUpdateManyInput
  field_stages: StageStructUpdateManyWithoutMapInput
}

input MapUpdateWithWhereUniqueWithoutContinentInput {
  where: MapWhereUniqueInput!
  data: MapUpdateWithoutContinentDataInput!
}

input MapUpdateWithWhereUniqueWithoutNative_bossInput {
  where: MapWhereUniqueInput!
  data: MapUpdateWithoutNative_bossDataInput!
}

input MapUpsertNestedInput {
  update: MapUpdateDataInput!
  create: MapCreateInput!
}

input MapUpsertWithoutConnected_mapsInput {
  update: MapUpdateWithoutConnected_mapsDataInput!
  create: MapCreateWithoutConnected_mapsInput!
}

input MapUpsertWithoutField_stagesInput {
  update: MapUpdateWithoutField_stagesDataInput!
  create: MapCreateWithoutField_stagesInput!
}

input MapUpsertWithoutObtainable_skillsInput {
  update: MapUpdateWithoutObtainable_skillsDataInput!
  create: MapCreateWithoutObtainable_skillsInput!
}

input MapUpsertWithWhereUniqueWithoutContinentInput {
  where: MapWhereUniqueInput!
  update: MapUpdateWithoutContinentDataInput!
  create: MapCreateWithoutContinentInput!
}

input MapUpsertWithWhereUniqueWithoutNative_bossInput {
  where: MapWhereUniqueInput!
  update: MapUpdateWithoutNative_bossDataInput!
  create: MapCreateWithoutNative_bossInput!
}

input MapWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  total_stage: Int
  total_stage_not: Int
  total_stage_in: [Int!]
  total_stage_not_in: [Int!]
  total_stage_lt: Int
  total_stage_lte: Int
  total_stage_gt: Int
  total_stage_gte: Int
  native_boss_every: BossWhereInput
  native_boss_some: BossWhereInput
  native_boss_none: BossWhereInput
  connected_maps: ConnectedMapWhereInput
  continent: ContinentWhereInput
  obtainable_skills_every: SkillWhereInput
  obtainable_skills_some: SkillWhereInput
  obtainable_skills_none: SkillWhereInput
  boss_stages_every: BossStructWhereInput
  boss_stages_some: BossStructWhereInput
  boss_stages_none: BossStructWhereInput
  field_stages_every: StageStructWhereInput
  field_stages_some: StageStructWhereInput
  field_stages_none: StageStructWhereInput
  AND: [MapWhereInput!]
  OR: [MapWhereInput!]
  NOT: [MapWhereInput!]
}

input MapWhereUniqueInput {
  id: ID
  name: String
}

type MonsterSkill {
  id: ID!
  name: String!
  description: String!
  skill_type: SkillType
  combat_type: CombatType
  energy: Int!
}

type MonsterSkillConnection {
  pageInfo: PageInfo!
  edges: [MonsterSkillEdge]!
  aggregate: AggregateMonsterSkill!
}

input MonsterSkillCreateInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillType
  combat_type: CombatType
  energy: Int
}

input MonsterSkillCreateManyInput {
  create: [MonsterSkillCreateInput!]
  connect: [MonsterSkillWhereUniqueInput!]
}

type MonsterSkillEdge {
  node: MonsterSkill!
  cursor: String!
}

enum MonsterSkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  skill_type_ASC
  skill_type_DESC
  combat_type_ASC
  combat_type_DESC
  energy_ASC
  energy_DESC
}

type MonsterSkillPreviousValues {
  id: ID!
  name: String!
  description: String!
  skill_type: SkillType
  combat_type: CombatType
  energy: Int!
}

input MonsterSkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  skill_type: SkillType
  skill_type_not: SkillType
  skill_type_in: [SkillType!]
  skill_type_not_in: [SkillType!]
  combat_type: CombatType
  combat_type_not: CombatType
  combat_type_in: [CombatType!]
  combat_type_not_in: [CombatType!]
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  AND: [MonsterSkillScalarWhereInput!]
  OR: [MonsterSkillScalarWhereInput!]
  NOT: [MonsterSkillScalarWhereInput!]
}

type MonsterSkillSubscriptionPayload {
  mutation: MutationType!
  node: MonsterSkill
  updatedFields: [String!]
  previousValues: MonsterSkillPreviousValues
}

input MonsterSkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MonsterSkillWhereInput
  AND: [MonsterSkillSubscriptionWhereInput!]
  OR: [MonsterSkillSubscriptionWhereInput!]
  NOT: [MonsterSkillSubscriptionWhereInput!]
}

input MonsterSkillUpdateDataInput {
  name: String
  description: String
  skill_type: SkillType
  combat_type: CombatType
  energy: Int
}

input MonsterSkillUpdateInput {
  name: String
  description: String
  skill_type: SkillType
  combat_type: CombatType
  energy: Int
}

input MonsterSkillUpdateManyDataInput {
  name: String
  description: String
  skill_type: SkillType
  combat_type: CombatType
  energy: Int
}

input MonsterSkillUpdateManyInput {
  create: [MonsterSkillCreateInput!]
  update: [MonsterSkillUpdateWithWhereUniqueNestedInput!]
  upsert: [MonsterSkillUpsertWithWhereUniqueNestedInput!]
  delete: [MonsterSkillWhereUniqueInput!]
  connect: [MonsterSkillWhereUniqueInput!]
  set: [MonsterSkillWhereUniqueInput!]
  disconnect: [MonsterSkillWhereUniqueInput!]
  deleteMany: [MonsterSkillScalarWhereInput!]
  updateMany: [MonsterSkillUpdateManyWithWhereNestedInput!]
}

input MonsterSkillUpdateManyMutationInput {
  name: String
  description: String
  skill_type: SkillType
  combat_type: CombatType
  energy: Int
}

input MonsterSkillUpdateManyWithWhereNestedInput {
  where: MonsterSkillScalarWhereInput!
  data: MonsterSkillUpdateManyDataInput!
}

input MonsterSkillUpdateWithWhereUniqueNestedInput {
  where: MonsterSkillWhereUniqueInput!
  data: MonsterSkillUpdateDataInput!
}

input MonsterSkillUpsertWithWhereUniqueNestedInput {
  where: MonsterSkillWhereUniqueInput!
  update: MonsterSkillUpdateDataInput!
  create: MonsterSkillCreateInput!
}

input MonsterSkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  skill_type: SkillType
  skill_type_not: SkillType
  skill_type_in: [SkillType!]
  skill_type_not_in: [SkillType!]
  combat_type: CombatType
  combat_type_not: CombatType
  combat_type_in: [CombatType!]
  combat_type_not_in: [CombatType!]
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  AND: [MonsterSkillWhereInput!]
  OR: [MonsterSkillWhereInput!]
  NOT: [MonsterSkillWhereInput!]
}

input MonsterSkillWhereUniqueInput {
  id: ID
  name: String
}

type Mutation {
  createBoss(data: BossCreateInput!): Boss!
  updateBoss(data: BossUpdateInput!, where: BossWhereUniqueInput!): Boss
  updateManyBosses(data: BossUpdateManyMutationInput!, where: BossWhereInput): BatchPayload!
  upsertBoss(where: BossWhereUniqueInput!, create: BossCreateInput!, update: BossUpdateInput!): Boss!
  deleteBoss(where: BossWhereUniqueInput!): Boss
  deleteManyBosses(where: BossWhereInput): BatchPayload!
  createBossStruct(data: BossStructCreateInput!): BossStruct!
  updateBossStruct(data: BossStructUpdateInput!, where: BossStructWhereUniqueInput!): BossStruct
  updateManyBossStructs(data: BossStructUpdateManyMutationInput!, where: BossStructWhereInput): BatchPayload!
  upsertBossStruct(where: BossStructWhereUniqueInput!, create: BossStructCreateInput!, update: BossStructUpdateInput!): BossStruct!
  deleteBossStruct(where: BossStructWhereUniqueInput!): BossStruct
  deleteManyBossStructs(where: BossStructWhereInput): BatchPayload!
  createClass(data: ClassCreateInput!): Class!
  updateClass(data: ClassUpdateInput!, where: ClassWhereUniqueInput!): Class
  updateManyClasses(data: ClassUpdateManyMutationInput!, where: ClassWhereInput): BatchPayload!
  upsertClass(where: ClassWhereUniqueInput!, create: ClassCreateInput!, update: ClassUpdateInput!): Class!
  deleteClass(where: ClassWhereUniqueInput!): Class
  deleteManyClasses(where: ClassWhereInput): BatchPayload!
  createConnectContinent(data: ConnectContinentCreateInput!): ConnectContinent!
  updateConnectContinent(data: ConnectContinentUpdateInput!, where: ConnectContinentWhereUniqueInput!): ConnectContinent
  upsertConnectContinent(where: ConnectContinentWhereUniqueInput!, create: ConnectContinentCreateInput!, update: ConnectContinentUpdateInput!): ConnectContinent!
  deleteConnectContinent(where: ConnectContinentWhereUniqueInput!): ConnectContinent
  deleteManyConnectContinents(where: ConnectContinentWhereInput): BatchPayload!
  createConnectedMap(data: ConnectedMapCreateInput!): ConnectedMap!
  updateConnectedMap(data: ConnectedMapUpdateInput!, where: ConnectedMapWhereUniqueInput!): ConnectedMap
  upsertConnectedMap(where: ConnectedMapWhereUniqueInput!, create: ConnectedMapCreateInput!, update: ConnectedMapUpdateInput!): ConnectedMap!
  deleteConnectedMap(where: ConnectedMapWhereUniqueInput!): ConnectedMap
  deleteManyConnectedMaps(where: ConnectedMapWhereInput): BatchPayload!
  createContinent(data: ContinentCreateInput!): Continent!
  updateContinent(data: ContinentUpdateInput!, where: ContinentWhereUniqueInput!): Continent
  updateManyContinents(data: ContinentUpdateManyMutationInput!, where: ContinentWhereInput): BatchPayload!
  upsertContinent(where: ContinentWhereUniqueInput!, create: ContinentCreateInput!, update: ContinentUpdateInput!): Continent!
  deleteContinent(where: ContinentWhereUniqueInput!): Continent
  deleteManyContinents(where: ContinentWhereInput): BatchPayload!
  createElement(data: ElementCreateInput!): Element!
  updateElement(data: ElementUpdateInput!, where: ElementWhereUniqueInput!): Element
  updateManyElements(data: ElementUpdateManyMutationInput!, where: ElementWhereInput): BatchPayload!
  upsertElement(where: ElementWhereUniqueInput!, create: ElementCreateInput!, update: ElementUpdateInput!): Element!
  deleteElement(where: ElementWhereUniqueInput!): Element
  deleteManyElements(where: ElementWhereInput): BatchPayload!
  createGuide(data: GuideCreateInput!): Guide!
  updateGuide(data: GuideUpdateInput!, where: GuideWhereUniqueInput!): Guide
  updateManyGuides(data: GuideUpdateManyMutationInput!, where: GuideWhereInput): BatchPayload!
  upsertGuide(where: GuideWhereUniqueInput!, create: GuideCreateInput!, update: GuideUpdateInput!): Guide!
  deleteGuide(where: GuideWhereUniqueInput!): Guide
  deleteManyGuides(where: GuideWhereInput): BatchPayload!
  createMap(data: MapCreateInput!): Map!
  updateMap(data: MapUpdateInput!, where: MapWhereUniqueInput!): Map
  updateManyMaps(data: MapUpdateManyMutationInput!, where: MapWhereInput): BatchPayload!
  upsertMap(where: MapWhereUniqueInput!, create: MapCreateInput!, update: MapUpdateInput!): Map!
  deleteMap(where: MapWhereUniqueInput!): Map
  deleteManyMaps(where: MapWhereInput): BatchPayload!
  createMonsterSkill(data: MonsterSkillCreateInput!): MonsterSkill!
  updateMonsterSkill(data: MonsterSkillUpdateInput!, where: MonsterSkillWhereUniqueInput!): MonsterSkill
  updateManyMonsterSkills(data: MonsterSkillUpdateManyMutationInput!, where: MonsterSkillWhereInput): BatchPayload!
  upsertMonsterSkill(where: MonsterSkillWhereUniqueInput!, create: MonsterSkillCreateInput!, update: MonsterSkillUpdateInput!): MonsterSkill!
  deleteMonsterSkill(where: MonsterSkillWhereUniqueInput!): MonsterSkill
  deleteManyMonsterSkills(where: MonsterSkillWhereInput): BatchPayload!
  createSkill(data: SkillCreateInput!): Skill!
  updateSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateManySkills(data: SkillUpdateManyMutationInput!, where: SkillWhereInput): BatchPayload!
  upsertSkill(where: SkillWhereUniqueInput!, create: SkillCreateInput!, update: SkillUpdateInput!): Skill!
  deleteSkill(where: SkillWhereUniqueInput!): Skill
  deleteManySkills(where: SkillWhereInput): BatchPayload!
  createStageStruct(data: StageStructCreateInput!): StageStruct!
  updateStageStruct(data: StageStructUpdateInput!, where: StageStructWhereUniqueInput!): StageStruct
  updateManyStageStructs(data: StageStructUpdateManyMutationInput!, where: StageStructWhereInput): BatchPayload!
  upsertStageStruct(where: StageStructWhereUniqueInput!, create: StageStructCreateInput!, update: StageStructUpdateInput!): StageStruct!
  deleteStageStruct(where: StageStructWhereUniqueInput!): StageStruct
  deleteManyStageStructs(where: StageStructWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  boss(where: BossWhereUniqueInput!): Boss
  bosses(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss]!
  bossesConnection(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BossConnection!
  bossStruct(where: BossStructWhereUniqueInput!): BossStruct
  bossStructs(where: BossStructWhereInput, orderBy: BossStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BossStruct]!
  bossStructsConnection(where: BossStructWhereInput, orderBy: BossStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BossStructConnection!
  class(where: ClassWhereUniqueInput!): Class
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class]!
  classesConnection(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassConnection!
  connectContinent(where: ConnectContinentWhereUniqueInput!): ConnectContinent
  connectContinents(where: ConnectContinentWhereInput, orderBy: ConnectContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ConnectContinent]!
  connectContinentsConnection(where: ConnectContinentWhereInput, orderBy: ConnectContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConnectContinentConnection!
  connectedMap(where: ConnectedMapWhereUniqueInput!): ConnectedMap
  connectedMaps(where: ConnectedMapWhereInput, orderBy: ConnectedMapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ConnectedMap]!
  connectedMapsConnection(where: ConnectedMapWhereInput, orderBy: ConnectedMapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConnectedMapConnection!
  continent(where: ContinentWhereUniqueInput!): Continent
  continents(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Continent]!
  continentsConnection(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContinentConnection!
  element(where: ElementWhereUniqueInput!): Element
  elements(where: ElementWhereInput, orderBy: ElementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Element]!
  elementsConnection(where: ElementWhereInput, orderBy: ElementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ElementConnection!
  guide(where: GuideWhereUniqueInput!): Guide
  guides(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guide]!
  guidesConnection(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuideConnection!
  map(where: MapWhereUniqueInput!): Map
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map]!
  mapsConnection(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MapConnection!
  monsterSkill(where: MonsterSkillWhereUniqueInput!): MonsterSkill
  monsterSkills(where: MonsterSkillWhereInput, orderBy: MonsterSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MonsterSkill]!
  monsterSkillsConnection(where: MonsterSkillWhereInput, orderBy: MonsterSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MonsterSkillConnection!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill]!
  skillsConnection(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SkillConnection!
  stageStruct(where: StageStructWhereUniqueInput!): StageStruct
  stageStructs(where: StageStructWhereInput, orderBy: StageStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [StageStruct]!
  stageStructsConnection(where: StageStructWhereInput, orderBy: StageStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StageStructConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  ADMIN
  MODERATOR
  USER
}

type Skill {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  combat_type: [CombatType!]!
  energy: Int!
  location: Map
  class: Class
}

type SkillConnection {
  pageInfo: PageInfo!
  edges: [SkillEdge]!
  aggregate: AggregateSkill!
}

input SkillCreatecombat_typeInput {
  set: [CombatType!]
}

input SkillCreateInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  combat_type: SkillCreatecombat_typeInput
  energy: Int
  location: MapCreateOneWithoutObtainable_skillsInput
  class: ClassCreateOneWithoutSkillsInput
}

input SkillCreateManyWithoutClassInput {
  create: [SkillCreateWithoutClassInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateManyWithoutLocationInput {
  create: [SkillCreateWithoutLocationInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateskill_typeInput {
  set: [SkillType!]
}

input SkillCreateWithoutClassInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  combat_type: SkillCreatecombat_typeInput
  energy: Int
  location: MapCreateOneWithoutObtainable_skillsInput
}

input SkillCreateWithoutLocationInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  combat_type: SkillCreatecombat_typeInput
  energy: Int
  class: ClassCreateOneWithoutSkillsInput
}

type SkillEdge {
  node: Skill!
  cursor: String!
}

enum SkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  energy_ASC
  energy_DESC
}

type SkillPreviousValues {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  combat_type: [CombatType!]!
  energy: Int!
}

input SkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  AND: [SkillScalarWhereInput!]
  OR: [SkillScalarWhereInput!]
  NOT: [SkillScalarWhereInput!]
}

type SkillSubscriptionPayload {
  mutation: MutationType!
  node: Skill
  updatedFields: [String!]
  previousValues: SkillPreviousValues
}

input SkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SkillWhereInput
  AND: [SkillSubscriptionWhereInput!]
  OR: [SkillSubscriptionWhereInput!]
  NOT: [SkillSubscriptionWhereInput!]
}

enum SkillType {
  UNKNOWN
  BUFF
  BUFF_AOE
  DAMAGE_TARGET
  DAMAGE_AOE
  DAMAGE_DOT
  HEAL_TARGET
  HEAL_AOE
  HEAL_DOT
  CROWD_CONTROL
  SUMMON
  DEBUFF
  DISPELL
  ABSORB
  STEALTH
  PASSIVE
}

input SkillUpdatecombat_typeInput {
  set: [CombatType!]
}

input SkillUpdateInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
  location: MapUpdateOneWithoutObtainable_skillsInput
  class: ClassUpdateOneWithoutSkillsInput
}

input SkillUpdateManyDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
}

input SkillUpdateManyMutationInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
}

input SkillUpdateManyWithoutClassInput {
  create: [SkillCreateWithoutClassInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutClassInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutClassInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyWithoutLocationInput {
  create: [SkillCreateWithoutLocationInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutLocationInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutLocationInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput!
  data: SkillUpdateManyDataInput!
}

input SkillUpdateskill_typeInput {
  set: [SkillType!]
}

input SkillUpdateWithoutClassDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
  location: MapUpdateOneWithoutObtainable_skillsInput
}

input SkillUpdateWithoutLocationDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
  class: ClassUpdateOneWithoutSkillsInput
}

input SkillUpdateWithWhereUniqueWithoutClassInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateWithoutClassDataInput!
}

input SkillUpdateWithWhereUniqueWithoutLocationInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateWithoutLocationDataInput!
}

input SkillUpsertWithWhereUniqueWithoutClassInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateWithoutClassDataInput!
  create: SkillCreateWithoutClassInput!
}

input SkillUpsertWithWhereUniqueWithoutLocationInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateWithoutLocationDataInput!
  create: SkillCreateWithoutLocationInput!
}

input SkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  location: MapWhereInput
  class: ClassWhereInput
  AND: [SkillWhereInput!]
  OR: [SkillWhereInput!]
  NOT: [SkillWhereInput!]
}

input SkillWhereUniqueInput {
  id: ID
  name: String
}

type StageStruct {
  id: ID!
  stage_number: Int!
  map: Map!
  base_exp: Int
  gear_level: Int
  base_shell: Int
  boss_found: BossStruct
}

type StageStructConnection {
  pageInfo: PageInfo!
  edges: [StageStructEdge]!
  aggregate: AggregateStageStruct!
}

input StageStructCreateInput {
  id: ID
  stage_number: Int!
  map: MapCreateOneWithoutField_stagesInput!
  base_exp: Int
  gear_level: Int
  base_shell: Int
  boss_found: BossStructCreateOneWithoutLocationInput
}

input StageStructCreateManyWithoutMapInput {
  create: [StageStructCreateWithoutMapInput!]
  connect: [StageStructWhereUniqueInput!]
}

input StageStructCreateOneWithoutBoss_foundInput {
  create: StageStructCreateWithoutBoss_foundInput
  connect: StageStructWhereUniqueInput
}

input StageStructCreateWithoutBoss_foundInput {
  id: ID
  stage_number: Int!
  map: MapCreateOneWithoutField_stagesInput!
  base_exp: Int
  gear_level: Int
  base_shell: Int
}

input StageStructCreateWithoutMapInput {
  id: ID
  stage_number: Int!
  base_exp: Int
  gear_level: Int
  base_shell: Int
  boss_found: BossStructCreateOneWithoutLocationInput
}

type StageStructEdge {
  node: StageStruct!
  cursor: String!
}

enum StageStructOrderByInput {
  id_ASC
  id_DESC
  stage_number_ASC
  stage_number_DESC
  base_exp_ASC
  base_exp_DESC
  gear_level_ASC
  gear_level_DESC
  base_shell_ASC
  base_shell_DESC
}

type StageStructPreviousValues {
  id: ID!
  stage_number: Int!
  base_exp: Int
  gear_level: Int
  base_shell: Int
}

input StageStructScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stage_number: Int
  stage_number_not: Int
  stage_number_in: [Int!]
  stage_number_not_in: [Int!]
  stage_number_lt: Int
  stage_number_lte: Int
  stage_number_gt: Int
  stage_number_gte: Int
  base_exp: Int
  base_exp_not: Int
  base_exp_in: [Int!]
  base_exp_not_in: [Int!]
  base_exp_lt: Int
  base_exp_lte: Int
  base_exp_gt: Int
  base_exp_gte: Int
  gear_level: Int
  gear_level_not: Int
  gear_level_in: [Int!]
  gear_level_not_in: [Int!]
  gear_level_lt: Int
  gear_level_lte: Int
  gear_level_gt: Int
  gear_level_gte: Int
  base_shell: Int
  base_shell_not: Int
  base_shell_in: [Int!]
  base_shell_not_in: [Int!]
  base_shell_lt: Int
  base_shell_lte: Int
  base_shell_gt: Int
  base_shell_gte: Int
  AND: [StageStructScalarWhereInput!]
  OR: [StageStructScalarWhereInput!]
  NOT: [StageStructScalarWhereInput!]
}

type StageStructSubscriptionPayload {
  mutation: MutationType!
  node: StageStruct
  updatedFields: [String!]
  previousValues: StageStructPreviousValues
}

input StageStructSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StageStructWhereInput
  AND: [StageStructSubscriptionWhereInput!]
  OR: [StageStructSubscriptionWhereInput!]
  NOT: [StageStructSubscriptionWhereInput!]
}

input StageStructUpdateInput {
  stage_number: Int
  map: MapUpdateOneRequiredWithoutField_stagesInput
  base_exp: Int
  gear_level: Int
  base_shell: Int
  boss_found: BossStructUpdateOneWithoutLocationInput
}

input StageStructUpdateManyDataInput {
  stage_number: Int
  base_exp: Int
  gear_level: Int
  base_shell: Int
}

input StageStructUpdateManyMutationInput {
  stage_number: Int
  base_exp: Int
  gear_level: Int
  base_shell: Int
}

input StageStructUpdateManyWithoutMapInput {
  create: [StageStructCreateWithoutMapInput!]
  delete: [StageStructWhereUniqueInput!]
  connect: [StageStructWhereUniqueInput!]
  set: [StageStructWhereUniqueInput!]
  disconnect: [StageStructWhereUniqueInput!]
  update: [StageStructUpdateWithWhereUniqueWithoutMapInput!]
  upsert: [StageStructUpsertWithWhereUniqueWithoutMapInput!]
  deleteMany: [StageStructScalarWhereInput!]
  updateMany: [StageStructUpdateManyWithWhereNestedInput!]
}

input StageStructUpdateManyWithWhereNestedInput {
  where: StageStructScalarWhereInput!
  data: StageStructUpdateManyDataInput!
}

input StageStructUpdateOneWithoutBoss_foundInput {
  create: StageStructCreateWithoutBoss_foundInput
  update: StageStructUpdateWithoutBoss_foundDataInput
  upsert: StageStructUpsertWithoutBoss_foundInput
  delete: Boolean
  disconnect: Boolean
  connect: StageStructWhereUniqueInput
}

input StageStructUpdateWithoutBoss_foundDataInput {
  stage_number: Int
  map: MapUpdateOneRequiredWithoutField_stagesInput
  base_exp: Int
  gear_level: Int
  base_shell: Int
}

input StageStructUpdateWithoutMapDataInput {
  stage_number: Int
  base_exp: Int
  gear_level: Int
  base_shell: Int
  boss_found: BossStructUpdateOneWithoutLocationInput
}

input StageStructUpdateWithWhereUniqueWithoutMapInput {
  where: StageStructWhereUniqueInput!
  data: StageStructUpdateWithoutMapDataInput!
}

input StageStructUpsertWithoutBoss_foundInput {
  update: StageStructUpdateWithoutBoss_foundDataInput!
  create: StageStructCreateWithoutBoss_foundInput!
}

input StageStructUpsertWithWhereUniqueWithoutMapInput {
  where: StageStructWhereUniqueInput!
  update: StageStructUpdateWithoutMapDataInput!
  create: StageStructCreateWithoutMapInput!
}

input StageStructWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stage_number: Int
  stage_number_not: Int
  stage_number_in: [Int!]
  stage_number_not_in: [Int!]
  stage_number_lt: Int
  stage_number_lte: Int
  stage_number_gt: Int
  stage_number_gte: Int
  map: MapWhereInput
  base_exp: Int
  base_exp_not: Int
  base_exp_in: [Int!]
  base_exp_not_in: [Int!]
  base_exp_lt: Int
  base_exp_lte: Int
  base_exp_gt: Int
  base_exp_gte: Int
  gear_level: Int
  gear_level_not: Int
  gear_level_in: [Int!]
  gear_level_not_in: [Int!]
  gear_level_lt: Int
  gear_level_lte: Int
  gear_level_gt: Int
  gear_level_gte: Int
  base_shell: Int
  base_shell_not: Int
  base_shell_in: [Int!]
  base_shell_not_in: [Int!]
  base_shell_lt: Int
  base_shell_lte: Int
  base_shell_gt: Int
  base_shell_gte: Int
  boss_found: BossStructWhereInput
  AND: [StageStructWhereInput!]
  OR: [StageStructWhereInput!]
  NOT: [StageStructWhereInput!]
}

input StageStructWhereUniqueInput {
  id: ID
}

type Subscription {
  boss(where: BossSubscriptionWhereInput): BossSubscriptionPayload
  bossStruct(where: BossStructSubscriptionWhereInput): BossStructSubscriptionPayload
  class(where: ClassSubscriptionWhereInput): ClassSubscriptionPayload
  connectContinent(where: ConnectContinentSubscriptionWhereInput): ConnectContinentSubscriptionPayload
  connectedMap(where: ConnectedMapSubscriptionWhereInput): ConnectedMapSubscriptionPayload
  continent(where: ContinentSubscriptionWhereInput): ContinentSubscriptionPayload
  element(where: ElementSubscriptionWhereInput): ElementSubscriptionPayload
  guide(where: GuideSubscriptionWhereInput): GuideSubscriptionPayload
  map(where: MapSubscriptionWhereInput): MapSubscriptionPayload
  monsterSkill(where: MonsterSkillSubscriptionWhereInput): MonsterSkillSubscriptionPayload
  skill(where: SkillSubscriptionWhereInput): SkillSubscriptionPayload
  stageStruct(where: StageStructSubscriptionWhereInput): StageStructSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role!
  password: String!
  guides(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guide!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role
  password: String!
  guides: GuideCreateManyWithoutOwnerInput
}

input UserCreateOneWithoutGuidesInput {
  create: UserCreateWithoutGuidesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutGuidesInput {
  id: ID
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updateAt_ASC
  updateAt_DESC
  handle_ASC
  handle_DESC
  email_ASC
  email_DESC
  role_ASC
  role_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  updateAt: DateTime
  handle: String
  email: String
  role: Role
  password: String
  guides: GuideUpdateManyWithoutOwnerInput
}

input UserUpdateManyMutationInput {
  updateAt: DateTime
  handle: String
  email: String
  role: Role
  password: String
}

input UserUpdateOneRequiredWithoutGuidesInput {
  create: UserCreateWithoutGuidesInput
  update: UserUpdateWithoutGuidesDataInput
  upsert: UserUpsertWithoutGuidesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutGuidesDataInput {
  updateAt: DateTime
  handle: String
  email: String
  role: Role
  password: String
}

input UserUpsertWithoutGuidesInput {
  update: UserUpdateWithoutGuidesDataInput!
  create: UserCreateWithoutGuidesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  guides_every: GuideWhereInput
  guides_some: GuideWhereInput
  guides_none: GuideWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  handle: String
  email: String
}
`
      }
    