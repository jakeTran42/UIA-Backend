module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBoss {
  count: Int!
}

type AggregateClass {
  count: Int!
}

type AggregateContinent {
  count: Int!
}

type AggregateGuide {
  count: Int!
}

type AggregateMap {
  count: Int!
}

type AggregateSkill {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Boss {
  id: ID!
  name: String!
  HP: Int!
  ATK: Int!
  Armor: Int!
  AtkSpd: Int!
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
}

type BossConnection {
  pageInfo: PageInfo!
  edges: [BossEdge]!
  aggregate: AggregateBoss!
}

input BossCreateInput {
  id: ID
  name: String!
  HP: Int!
  ATK: Int!
  Armor: Int!
  AtkSpd: Int!
  skills: SkillCreateManyInput
}

input BossCreateManyInput {
  create: [BossCreateInput!]
  connect: [BossWhereUniqueInput!]
}

type BossEdge {
  node: Boss!
  cursor: String!
}

enum BossOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  HP_ASC
  HP_DESC
  ATK_ASC
  ATK_DESC
  Armor_ASC
  Armor_DESC
  AtkSpd_ASC
  AtkSpd_DESC
}

type BossPreviousValues {
  id: ID!
  name: String!
  HP: Int!
  ATK: Int!
  Armor: Int!
  AtkSpd: Int!
}

input BossScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  HP: Int
  HP_not: Int
  HP_in: [Int!]
  HP_not_in: [Int!]
  HP_lt: Int
  HP_lte: Int
  HP_gt: Int
  HP_gte: Int
  ATK: Int
  ATK_not: Int
  ATK_in: [Int!]
  ATK_not_in: [Int!]
  ATK_lt: Int
  ATK_lte: Int
  ATK_gt: Int
  ATK_gte: Int
  Armor: Int
  Armor_not: Int
  Armor_in: [Int!]
  Armor_not_in: [Int!]
  Armor_lt: Int
  Armor_lte: Int
  Armor_gt: Int
  Armor_gte: Int
  AtkSpd: Int
  AtkSpd_not: Int
  AtkSpd_in: [Int!]
  AtkSpd_not_in: [Int!]
  AtkSpd_lt: Int
  AtkSpd_lte: Int
  AtkSpd_gt: Int
  AtkSpd_gte: Int
  AND: [BossScalarWhereInput!]
  OR: [BossScalarWhereInput!]
  NOT: [BossScalarWhereInput!]
}

type BossSubscriptionPayload {
  mutation: MutationType!
  node: Boss
  updatedFields: [String!]
  previousValues: BossPreviousValues
}

input BossSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BossWhereInput
  AND: [BossSubscriptionWhereInput!]
  OR: [BossSubscriptionWhereInput!]
  NOT: [BossSubscriptionWhereInput!]
}

input BossUpdateDataInput {
  name: String
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Int
  skills: SkillUpdateManyInput
}

input BossUpdateInput {
  name: String
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Int
  skills: SkillUpdateManyInput
}

input BossUpdateManyDataInput {
  name: String
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Int
}

input BossUpdateManyInput {
  create: [BossCreateInput!]
  update: [BossUpdateWithWhereUniqueNestedInput!]
  upsert: [BossUpsertWithWhereUniqueNestedInput!]
  delete: [BossWhereUniqueInput!]
  connect: [BossWhereUniqueInput!]
  set: [BossWhereUniqueInput!]
  disconnect: [BossWhereUniqueInput!]
  deleteMany: [BossScalarWhereInput!]
  updateMany: [BossUpdateManyWithWhereNestedInput!]
}

input BossUpdateManyMutationInput {
  name: String
  HP: Int
  ATK: Int
  Armor: Int
  AtkSpd: Int
}

input BossUpdateManyWithWhereNestedInput {
  where: BossScalarWhereInput!
  data: BossUpdateManyDataInput!
}

input BossUpdateWithWhereUniqueNestedInput {
  where: BossWhereUniqueInput!
  data: BossUpdateDataInput!
}

input BossUpsertWithWhereUniqueNestedInput {
  where: BossWhereUniqueInput!
  update: BossUpdateDataInput!
  create: BossCreateInput!
}

input BossWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  HP: Int
  HP_not: Int
  HP_in: [Int!]
  HP_not_in: [Int!]
  HP_lt: Int
  HP_lte: Int
  HP_gt: Int
  HP_gte: Int
  ATK: Int
  ATK_not: Int
  ATK_in: [Int!]
  ATK_not_in: [Int!]
  ATK_lt: Int
  ATK_lte: Int
  ATK_gt: Int
  ATK_gte: Int
  Armor: Int
  Armor_not: Int
  Armor_in: [Int!]
  Armor_not_in: [Int!]
  Armor_lt: Int
  Armor_lte: Int
  Armor_gt: Int
  Armor_gte: Int
  AtkSpd: Int
  AtkSpd_not: Int
  AtkSpd_in: [Int!]
  AtkSpd_not_in: [Int!]
  AtkSpd_lt: Int
  AtkSpd_lte: Int
  AtkSpd_gt: Int
  AtkSpd_gte: Int
  skills_every: SkillWhereInput
  skills_some: SkillWhereInput
  skills_none: SkillWhereInput
  AND: [BossWhereInput!]
  OR: [BossWhereInput!]
  NOT: [BossWhereInput!]
}

input BossWhereUniqueInput {
  id: ID
}

type Class {
  id: ID!
  name: String!
  description: String!
  weapon: String!
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
}

type ClassConnection {
  pageInfo: PageInfo!
  edges: [ClassEdge]!
  aggregate: AggregateClass!
}

input ClassCreateInput {
  id: ID
  name: String!
  description: String!
  weapon: String!
  skills: SkillCreateManyWithoutClassInput
}

input ClassCreateOneWithoutSkillsInput {
  create: ClassCreateWithoutSkillsInput
  connect: ClassWhereUniqueInput
}

input ClassCreateWithoutSkillsInput {
  id: ID
  name: String!
  description: String!
  weapon: String!
}

type ClassEdge {
  node: Class!
  cursor: String!
}

enum ClassOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  weapon_ASC
  weapon_DESC
}

type ClassPreviousValues {
  id: ID!
  name: String!
  description: String!
  weapon: String!
}

type ClassSubscriptionPayload {
  mutation: MutationType!
  node: Class
  updatedFields: [String!]
  previousValues: ClassPreviousValues
}

input ClassSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassWhereInput
  AND: [ClassSubscriptionWhereInput!]
  OR: [ClassSubscriptionWhereInput!]
  NOT: [ClassSubscriptionWhereInput!]
}

input ClassUpdateInput {
  name: String
  description: String
  weapon: String
  skills: SkillUpdateManyWithoutClassInput
}

input ClassUpdateManyMutationInput {
  name: String
  description: String
  weapon: String
}

input ClassUpdateOneWithoutSkillsInput {
  create: ClassCreateWithoutSkillsInput
  update: ClassUpdateWithoutSkillsDataInput
  upsert: ClassUpsertWithoutSkillsInput
  delete: Boolean
  disconnect: Boolean
  connect: ClassWhereUniqueInput
}

input ClassUpdateWithoutSkillsDataInput {
  name: String
  description: String
  weapon: String
}

input ClassUpsertWithoutSkillsInput {
  update: ClassUpdateWithoutSkillsDataInput!
  create: ClassCreateWithoutSkillsInput!
}

input ClassWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  weapon: String
  weapon_not: String
  weapon_in: [String!]
  weapon_not_in: [String!]
  weapon_lt: String
  weapon_lte: String
  weapon_gt: String
  weapon_gte: String
  weapon_contains: String
  weapon_not_contains: String
  weapon_starts_with: String
  weapon_not_starts_with: String
  weapon_ends_with: String
  weapon_not_ends_with: String
  skills_every: SkillWhereInput
  skills_some: SkillWhereInput
  skills_none: SkillWhereInput
  AND: [ClassWhereInput!]
  OR: [ClassWhereInput!]
  NOT: [ClassWhereInput!]
}

input ClassWhereUniqueInput {
  id: ID
}

type Continent {
  id: ID!
  name: String
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map!]
  next_continent: Continent
  previous_continent: Continent
}

type ContinentConnection {
  pageInfo: PageInfo!
  edges: [ContinentEdge]!
  aggregate: AggregateContinent!
}

input ContinentCreateInput {
  id: ID
  name: String
  maps: MapCreateManyWithoutContinentInput
  next_continent: ContinentCreateOneWithoutNext_continentInput
  previous_continent: ContinentCreateOneWithoutPrevious_continentInput
}

input ContinentCreateOneWithoutMapsInput {
  create: ContinentCreateWithoutMapsInput
  connect: ContinentWhereUniqueInput
}

input ContinentCreateOneWithoutNext_continentInput {
  create: ContinentCreateWithoutNext_continentInput
  connect: ContinentWhereUniqueInput
}

input ContinentCreateOneWithoutPrevious_continentInput {
  create: ContinentCreateWithoutPrevious_continentInput
  connect: ContinentWhereUniqueInput
}

input ContinentCreateWithoutMapsInput {
  id: ID
  name: String
  next_continent: ContinentCreateOneWithoutNext_continentInput
  previous_continent: ContinentCreateOneWithoutPrevious_continentInput
}

input ContinentCreateWithoutNext_continentInput {
  id: ID
  name: String
  maps: MapCreateManyWithoutContinentInput
  previous_continent: ContinentCreateOneWithoutPrevious_continentInput
}

input ContinentCreateWithoutPrevious_continentInput {
  id: ID
  name: String
  maps: MapCreateManyWithoutContinentInput
  next_continent: ContinentCreateOneWithoutNext_continentInput
}

type ContinentEdge {
  node: Continent!
  cursor: String!
}

enum ContinentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ContinentPreviousValues {
  id: ID!
  name: String
}

type ContinentSubscriptionPayload {
  mutation: MutationType!
  node: Continent
  updatedFields: [String!]
  previousValues: ContinentPreviousValues
}

input ContinentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContinentWhereInput
  AND: [ContinentSubscriptionWhereInput!]
  OR: [ContinentSubscriptionWhereInput!]
  NOT: [ContinentSubscriptionWhereInput!]
}

input ContinentUpdateInput {
  name: String
  maps: MapUpdateManyWithoutContinentInput
  next_continent: ContinentUpdateOneWithoutNext_continentInput
  previous_continent: ContinentUpdateOneWithoutPrevious_continentInput
}

input ContinentUpdateManyMutationInput {
  name: String
}

input ContinentUpdateOneRequiredWithoutMapsInput {
  create: ContinentCreateWithoutMapsInput
  update: ContinentUpdateWithoutMapsDataInput
  upsert: ContinentUpsertWithoutMapsInput
  connect: ContinentWhereUniqueInput
}

input ContinentUpdateOneWithoutNext_continentInput {
  create: ContinentCreateWithoutNext_continentInput
  update: ContinentUpdateWithoutNext_continentDataInput
  upsert: ContinentUpsertWithoutNext_continentInput
  delete: Boolean
  disconnect: Boolean
  connect: ContinentWhereUniqueInput
}

input ContinentUpdateOneWithoutPrevious_continentInput {
  create: ContinentCreateWithoutPrevious_continentInput
  update: ContinentUpdateWithoutPrevious_continentDataInput
  upsert: ContinentUpsertWithoutPrevious_continentInput
  delete: Boolean
  disconnect: Boolean
  connect: ContinentWhereUniqueInput
}

input ContinentUpdateWithoutMapsDataInput {
  name: String
  next_continent: ContinentUpdateOneWithoutNext_continentInput
  previous_continent: ContinentUpdateOneWithoutPrevious_continentInput
}

input ContinentUpdateWithoutNext_continentDataInput {
  name: String
  maps: MapUpdateManyWithoutContinentInput
  previous_continent: ContinentUpdateOneWithoutPrevious_continentInput
}

input ContinentUpdateWithoutPrevious_continentDataInput {
  name: String
  maps: MapUpdateManyWithoutContinentInput
  next_continent: ContinentUpdateOneWithoutNext_continentInput
}

input ContinentUpsertWithoutMapsInput {
  update: ContinentUpdateWithoutMapsDataInput!
  create: ContinentCreateWithoutMapsInput!
}

input ContinentUpsertWithoutNext_continentInput {
  update: ContinentUpdateWithoutNext_continentDataInput!
  create: ContinentCreateWithoutNext_continentInput!
}

input ContinentUpsertWithoutPrevious_continentInput {
  update: ContinentUpdateWithoutPrevious_continentDataInput!
  create: ContinentCreateWithoutPrevious_continentInput!
}

input ContinentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  maps_every: MapWhereInput
  maps_some: MapWhereInput
  maps_none: MapWhereInput
  next_continent: ContinentWhereInput
  previous_continent: ContinentWhereInput
  AND: [ContinentWhereInput!]
  OR: [ContinentWhereInput!]
  NOT: [ContinentWhereInput!]
}

input ContinentWhereUniqueInput {
  id: ID
}

scalar DateTime

type Guide {
  id: ID!
  createdAt: DateTime!
  title: String!
  body: String!
  owner: User!
}

type GuideConnection {
  pageInfo: PageInfo!
  edges: [GuideEdge]!
  aggregate: AggregateGuide!
}

input GuideCreateInput {
  id: ID
  title: String!
  body: String!
  owner: UserCreateOneWithoutGuidesInput!
}

input GuideCreateManyWithoutOwnerInput {
  create: [GuideCreateWithoutOwnerInput!]
  connect: [GuideWhereUniqueInput!]
}

input GuideCreateWithoutOwnerInput {
  id: ID
  title: String!
  body: String!
}

type GuideEdge {
  node: Guide!
  cursor: String!
}

enum GuideOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  title_ASC
  title_DESC
  body_ASC
  body_DESC
}

type GuidePreviousValues {
  id: ID!
  createdAt: DateTime!
  title: String!
  body: String!
}

input GuideScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [GuideScalarWhereInput!]
  OR: [GuideScalarWhereInput!]
  NOT: [GuideScalarWhereInput!]
}

type GuideSubscriptionPayload {
  mutation: MutationType!
  node: Guide
  updatedFields: [String!]
  previousValues: GuidePreviousValues
}

input GuideSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuideWhereInput
  AND: [GuideSubscriptionWhereInput!]
  OR: [GuideSubscriptionWhereInput!]
  NOT: [GuideSubscriptionWhereInput!]
}

input GuideUpdateInput {
  title: String
  body: String
  owner: UserUpdateOneRequiredWithoutGuidesInput
}

input GuideUpdateManyDataInput {
  title: String
  body: String
}

input GuideUpdateManyMutationInput {
  title: String
  body: String
}

input GuideUpdateManyWithoutOwnerInput {
  create: [GuideCreateWithoutOwnerInput!]
  delete: [GuideWhereUniqueInput!]
  connect: [GuideWhereUniqueInput!]
  set: [GuideWhereUniqueInput!]
  disconnect: [GuideWhereUniqueInput!]
  update: [GuideUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [GuideUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [GuideScalarWhereInput!]
  updateMany: [GuideUpdateManyWithWhereNestedInput!]
}

input GuideUpdateManyWithWhereNestedInput {
  where: GuideScalarWhereInput!
  data: GuideUpdateManyDataInput!
}

input GuideUpdateWithoutOwnerDataInput {
  title: String
  body: String
}

input GuideUpdateWithWhereUniqueWithoutOwnerInput {
  where: GuideWhereUniqueInput!
  data: GuideUpdateWithoutOwnerDataInput!
}

input GuideUpsertWithWhereUniqueWithoutOwnerInput {
  where: GuideWhereUniqueInput!
  update: GuideUpdateWithoutOwnerDataInput!
  create: GuideCreateWithoutOwnerInput!
}

input GuideWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  owner: UserWhereInput
  AND: [GuideWhereInput!]
  OR: [GuideWhereInput!]
  NOT: [GuideWhereInput!]
}

input GuideWhereUniqueInput {
  id: ID
}

scalar Long

type Map {
  id: ID!
  name: String!
  total_stage: Int!
  bosses(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss!]
  previous_map: Map
  next_map: Map
  continent: Continent!
  obtainable_skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
}

type MapConnection {
  pageInfo: PageInfo!
  edges: [MapEdge]!
  aggregate: AggregateMap!
}

input MapCreateInput {
  id: ID
  name: String!
  total_stage: Int!
  bosses: BossCreateManyInput
  previous_map: MapCreateOneWithoutPrevious_mapInput
  next_map: MapCreateOneWithoutNext_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
  obtainable_skills: SkillCreateManyWithoutLocationInput
}

input MapCreateManyWithoutContinentInput {
  create: [MapCreateWithoutContinentInput!]
  connect: [MapWhereUniqueInput!]
}

input MapCreateOneWithoutNext_mapInput {
  create: MapCreateWithoutNext_mapInput
  connect: MapWhereUniqueInput
}

input MapCreateOneWithoutObtainable_skillsInput {
  create: MapCreateWithoutObtainable_skillsInput
  connect: MapWhereUniqueInput
}

input MapCreateOneWithoutPrevious_mapInput {
  create: MapCreateWithoutPrevious_mapInput
  connect: MapWhereUniqueInput
}

input MapCreateWithoutContinentInput {
  id: ID
  name: String!
  total_stage: Int!
  bosses: BossCreateManyInput
  previous_map: MapCreateOneWithoutPrevious_mapInput
  next_map: MapCreateOneWithoutNext_mapInput
  obtainable_skills: SkillCreateManyWithoutLocationInput
}

input MapCreateWithoutNext_mapInput {
  id: ID
  name: String!
  total_stage: Int!
  bosses: BossCreateManyInput
  previous_map: MapCreateOneWithoutPrevious_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
  obtainable_skills: SkillCreateManyWithoutLocationInput
}

input MapCreateWithoutObtainable_skillsInput {
  id: ID
  name: String!
  total_stage: Int!
  bosses: BossCreateManyInput
  previous_map: MapCreateOneWithoutPrevious_mapInput
  next_map: MapCreateOneWithoutNext_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
}

input MapCreateWithoutPrevious_mapInput {
  id: ID
  name: String!
  total_stage: Int!
  bosses: BossCreateManyInput
  next_map: MapCreateOneWithoutNext_mapInput
  continent: ContinentCreateOneWithoutMapsInput!
  obtainable_skills: SkillCreateManyWithoutLocationInput
}

type MapEdge {
  node: Map!
  cursor: String!
}

enum MapOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  total_stage_ASC
  total_stage_DESC
}

type MapPreviousValues {
  id: ID!
  name: String!
  total_stage: Int!
}

input MapScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  total_stage: Int
  total_stage_not: Int
  total_stage_in: [Int!]
  total_stage_not_in: [Int!]
  total_stage_lt: Int
  total_stage_lte: Int
  total_stage_gt: Int
  total_stage_gte: Int
  AND: [MapScalarWhereInput!]
  OR: [MapScalarWhereInput!]
  NOT: [MapScalarWhereInput!]
}

type MapSubscriptionPayload {
  mutation: MutationType!
  node: Map
  updatedFields: [String!]
  previousValues: MapPreviousValues
}

input MapSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MapWhereInput
  AND: [MapSubscriptionWhereInput!]
  OR: [MapSubscriptionWhereInput!]
  NOT: [MapSubscriptionWhereInput!]
}

input MapUpdateInput {
  name: String
  total_stage: Int
  bosses: BossUpdateManyInput
  previous_map: MapUpdateOneWithoutPrevious_mapInput
  next_map: MapUpdateOneWithoutNext_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
}

input MapUpdateManyDataInput {
  name: String
  total_stage: Int
}

input MapUpdateManyMutationInput {
  name: String
  total_stage: Int
}

input MapUpdateManyWithoutContinentInput {
  create: [MapCreateWithoutContinentInput!]
  delete: [MapWhereUniqueInput!]
  connect: [MapWhereUniqueInput!]
  set: [MapWhereUniqueInput!]
  disconnect: [MapWhereUniqueInput!]
  update: [MapUpdateWithWhereUniqueWithoutContinentInput!]
  upsert: [MapUpsertWithWhereUniqueWithoutContinentInput!]
  deleteMany: [MapScalarWhereInput!]
  updateMany: [MapUpdateManyWithWhereNestedInput!]
}

input MapUpdateManyWithWhereNestedInput {
  where: MapScalarWhereInput!
  data: MapUpdateManyDataInput!
}

input MapUpdateOneWithoutNext_mapInput {
  create: MapCreateWithoutNext_mapInput
  update: MapUpdateWithoutNext_mapDataInput
  upsert: MapUpsertWithoutNext_mapInput
  delete: Boolean
  disconnect: Boolean
  connect: MapWhereUniqueInput
}

input MapUpdateOneWithoutObtainable_skillsInput {
  create: MapCreateWithoutObtainable_skillsInput
  update: MapUpdateWithoutObtainable_skillsDataInput
  upsert: MapUpsertWithoutObtainable_skillsInput
  delete: Boolean
  disconnect: Boolean
  connect: MapWhereUniqueInput
}

input MapUpdateOneWithoutPrevious_mapInput {
  create: MapCreateWithoutPrevious_mapInput
  update: MapUpdateWithoutPrevious_mapDataInput
  upsert: MapUpsertWithoutPrevious_mapInput
  delete: Boolean
  disconnect: Boolean
  connect: MapWhereUniqueInput
}

input MapUpdateWithoutContinentDataInput {
  name: String
  total_stage: Int
  bosses: BossUpdateManyInput
  previous_map: MapUpdateOneWithoutPrevious_mapInput
  next_map: MapUpdateOneWithoutNext_mapInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
}

input MapUpdateWithoutNext_mapDataInput {
  name: String
  total_stage: Int
  bosses: BossUpdateManyInput
  previous_map: MapUpdateOneWithoutPrevious_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
}

input MapUpdateWithoutObtainable_skillsDataInput {
  name: String
  total_stage: Int
  bosses: BossUpdateManyInput
  previous_map: MapUpdateOneWithoutPrevious_mapInput
  next_map: MapUpdateOneWithoutNext_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
}

input MapUpdateWithoutPrevious_mapDataInput {
  name: String
  total_stage: Int
  bosses: BossUpdateManyInput
  next_map: MapUpdateOneWithoutNext_mapInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
}

input MapUpdateWithWhereUniqueWithoutContinentInput {
  where: MapWhereUniqueInput!
  data: MapUpdateWithoutContinentDataInput!
}

input MapUpsertWithoutNext_mapInput {
  update: MapUpdateWithoutNext_mapDataInput!
  create: MapCreateWithoutNext_mapInput!
}

input MapUpsertWithoutObtainable_skillsInput {
  update: MapUpdateWithoutObtainable_skillsDataInput!
  create: MapCreateWithoutObtainable_skillsInput!
}

input MapUpsertWithoutPrevious_mapInput {
  update: MapUpdateWithoutPrevious_mapDataInput!
  create: MapCreateWithoutPrevious_mapInput!
}

input MapUpsertWithWhereUniqueWithoutContinentInput {
  where: MapWhereUniqueInput!
  update: MapUpdateWithoutContinentDataInput!
  create: MapCreateWithoutContinentInput!
}

input MapWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  total_stage: Int
  total_stage_not: Int
  total_stage_in: [Int!]
  total_stage_not_in: [Int!]
  total_stage_lt: Int
  total_stage_lte: Int
  total_stage_gt: Int
  total_stage_gte: Int
  bosses_every: BossWhereInput
  bosses_some: BossWhereInput
  bosses_none: BossWhereInput
  previous_map: MapWhereInput
  next_map: MapWhereInput
  continent: ContinentWhereInput
  obtainable_skills_every: SkillWhereInput
  obtainable_skills_some: SkillWhereInput
  obtainable_skills_none: SkillWhereInput
  AND: [MapWhereInput!]
  OR: [MapWhereInput!]
  NOT: [MapWhereInput!]
}

input MapWhereUniqueInput {
  id: ID
}

type Mutation {
  createBoss(data: BossCreateInput!): Boss!
  updateBoss(data: BossUpdateInput!, where: BossWhereUniqueInput!): Boss
  updateManyBosses(data: BossUpdateManyMutationInput!, where: BossWhereInput): BatchPayload!
  upsertBoss(where: BossWhereUniqueInput!, create: BossCreateInput!, update: BossUpdateInput!): Boss!
  deleteBoss(where: BossWhereUniqueInput!): Boss
  deleteManyBosses(where: BossWhereInput): BatchPayload!
  createClass(data: ClassCreateInput!): Class!
  updateClass(data: ClassUpdateInput!, where: ClassWhereUniqueInput!): Class
  updateManyClasses(data: ClassUpdateManyMutationInput!, where: ClassWhereInput): BatchPayload!
  upsertClass(where: ClassWhereUniqueInput!, create: ClassCreateInput!, update: ClassUpdateInput!): Class!
  deleteClass(where: ClassWhereUniqueInput!): Class
  deleteManyClasses(where: ClassWhereInput): BatchPayload!
  createContinent(data: ContinentCreateInput!): Continent!
  updateContinent(data: ContinentUpdateInput!, where: ContinentWhereUniqueInput!): Continent
  updateManyContinents(data: ContinentUpdateManyMutationInput!, where: ContinentWhereInput): BatchPayload!
  upsertContinent(where: ContinentWhereUniqueInput!, create: ContinentCreateInput!, update: ContinentUpdateInput!): Continent!
  deleteContinent(where: ContinentWhereUniqueInput!): Continent
  deleteManyContinents(where: ContinentWhereInput): BatchPayload!
  createGuide(data: GuideCreateInput!): Guide!
  updateGuide(data: GuideUpdateInput!, where: GuideWhereUniqueInput!): Guide
  updateManyGuides(data: GuideUpdateManyMutationInput!, where: GuideWhereInput): BatchPayload!
  upsertGuide(where: GuideWhereUniqueInput!, create: GuideCreateInput!, update: GuideUpdateInput!): Guide!
  deleteGuide(where: GuideWhereUniqueInput!): Guide
  deleteManyGuides(where: GuideWhereInput): BatchPayload!
  createMap(data: MapCreateInput!): Map!
  updateMap(data: MapUpdateInput!, where: MapWhereUniqueInput!): Map
  updateManyMaps(data: MapUpdateManyMutationInput!, where: MapWhereInput): BatchPayload!
  upsertMap(where: MapWhereUniqueInput!, create: MapCreateInput!, update: MapUpdateInput!): Map!
  deleteMap(where: MapWhereUniqueInput!): Map
  deleteManyMaps(where: MapWhereInput): BatchPayload!
  createSkill(data: SkillCreateInput!): Skill!
  updateSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateManySkills(data: SkillUpdateManyMutationInput!, where: SkillWhereInput): BatchPayload!
  upsertSkill(where: SkillWhereUniqueInput!, create: SkillCreateInput!, update: SkillUpdateInput!): Skill!
  deleteSkill(where: SkillWhereUniqueInput!): Skill
  deleteManySkills(where: SkillWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  boss(where: BossWhereUniqueInput!): Boss
  bosses(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss]!
  bossesConnection(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BossConnection!
  class(where: ClassWhereUniqueInput!): Class
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class]!
  classesConnection(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassConnection!
  continent(where: ContinentWhereUniqueInput!): Continent
  continents(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Continent]!
  continentsConnection(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContinentConnection!
  guide(where: GuideWhereUniqueInput!): Guide
  guides(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guide]!
  guidesConnection(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuideConnection!
  map(where: MapWhereUniqueInput!): Map
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map]!
  mapsConnection(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MapConnection!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill]!
  skillsConnection(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SkillConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  ADMIN
  MODERATOR
  USER
}

type Skill {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  energy: Int!
  location: Map
  class: Class
}

type SkillConnection {
  pageInfo: PageInfo!
  edges: [SkillEdge]!
  aggregate: AggregateSkill!
}

input SkillCreateInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  energy: Int
  location: MapCreateOneWithoutObtainable_skillsInput
  class: ClassCreateOneWithoutSkillsInput
}

input SkillCreateManyInput {
  create: [SkillCreateInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateManyWithoutClassInput {
  create: [SkillCreateWithoutClassInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateManyWithoutLocationInput {
  create: [SkillCreateWithoutLocationInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateskill_typeInput {
  set: [SkillType!]
}

input SkillCreateWithoutClassInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  energy: Int
  location: MapCreateOneWithoutObtainable_skillsInput
}

input SkillCreateWithoutLocationInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  energy: Int
  class: ClassCreateOneWithoutSkillsInput
}

type SkillEdge {
  node: Skill!
  cursor: String!
}

enum SkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  energy_ASC
  energy_DESC
}

type SkillPreviousValues {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  energy: Int!
}

input SkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  AND: [SkillScalarWhereInput!]
  OR: [SkillScalarWhereInput!]
  NOT: [SkillScalarWhereInput!]
}

type SkillSubscriptionPayload {
  mutation: MutationType!
  node: Skill
  updatedFields: [String!]
  previousValues: SkillPreviousValues
}

input SkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SkillWhereInput
  AND: [SkillSubscriptionWhereInput!]
  OR: [SkillSubscriptionWhereInput!]
  NOT: [SkillSubscriptionWhereInput!]
}

enum SkillType {
  UNKNOWN
  BUFF
  BUFF_AOE
  DAMAGE_TARGET
  DAMAGE_AOE
  DAMAGE_DOT
  HEAL_TARGET
  HEAL_AOE
  HEAL_DOT
  TAUNT
  INTERUPT
  KNOCKUP
  SILENCE
  SUMMON
}

input SkillUpdateDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  energy: Int
  location: MapUpdateOneWithoutObtainable_skillsInput
  class: ClassUpdateOneWithoutSkillsInput
}

input SkillUpdateInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  energy: Int
  location: MapUpdateOneWithoutObtainable_skillsInput
  class: ClassUpdateOneWithoutSkillsInput
}

input SkillUpdateManyDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  energy: Int
}

input SkillUpdateManyInput {
  create: [SkillCreateInput!]
  update: [SkillUpdateWithWhereUniqueNestedInput!]
  upsert: [SkillUpsertWithWhereUniqueNestedInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyMutationInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  energy: Int
}

input SkillUpdateManyWithoutClassInput {
  create: [SkillCreateWithoutClassInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutClassInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutClassInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyWithoutLocationInput {
  create: [SkillCreateWithoutLocationInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutLocationInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutLocationInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput!
  data: SkillUpdateManyDataInput!
}

input SkillUpdateskill_typeInput {
  set: [SkillType!]
}

input SkillUpdateWithoutClassDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  energy: Int
  location: MapUpdateOneWithoutObtainable_skillsInput
}

input SkillUpdateWithoutLocationDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  energy: Int
  class: ClassUpdateOneWithoutSkillsInput
}

input SkillUpdateWithWhereUniqueNestedInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateDataInput!
}

input SkillUpdateWithWhereUniqueWithoutClassInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateWithoutClassDataInput!
}

input SkillUpdateWithWhereUniqueWithoutLocationInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateWithoutLocationDataInput!
}

input SkillUpsertWithWhereUniqueNestedInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateDataInput!
  create: SkillCreateInput!
}

input SkillUpsertWithWhereUniqueWithoutClassInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateWithoutClassDataInput!
  create: SkillCreateWithoutClassInput!
}

input SkillUpsertWithWhereUniqueWithoutLocationInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateWithoutLocationDataInput!
  create: SkillCreateWithoutLocationInput!
}

input SkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  location: MapWhereInput
  class: ClassWhereInput
  AND: [SkillWhereInput!]
  OR: [SkillWhereInput!]
  NOT: [SkillWhereInput!]
}

input SkillWhereUniqueInput {
  id: ID
}

type Subscription {
  boss(where: BossSubscriptionWhereInput): BossSubscriptionPayload
  class(where: ClassSubscriptionWhereInput): ClassSubscriptionPayload
  continent(where: ContinentSubscriptionWhereInput): ContinentSubscriptionPayload
  guide(where: GuideSubscriptionWhereInput): GuideSubscriptionPayload
  map(where: MapSubscriptionWhereInput): MapSubscriptionPayload
  skill(where: SkillSubscriptionWhereInput): SkillSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  handle: String!
  email: String!
  role: Role!
  password: String!
  guides(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guide!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  handle: String!
  email: String!
  role: Role
  password: String!
  guides: GuideCreateManyWithoutOwnerInput
}

input UserCreateOneWithoutGuidesInput {
  create: UserCreateWithoutGuidesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutGuidesInput {
  id: ID
  handle: String!
  email: String!
  role: Role
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  handle_ASC
  handle_DESC
  email_ASC
  email_DESC
  role_ASC
  role_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  handle: String!
  email: String!
  role: Role!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  handle: String
  email: String
  role: Role
  password: String
  guides: GuideUpdateManyWithoutOwnerInput
}

input UserUpdateManyMutationInput {
  handle: String
  email: String
  role: Role
  password: String
}

input UserUpdateOneRequiredWithoutGuidesInput {
  create: UserCreateWithoutGuidesInput
  update: UserUpdateWithoutGuidesDataInput
  upsert: UserUpsertWithoutGuidesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutGuidesDataInput {
  handle: String
  email: String
  role: Role
  password: String
}

input UserUpsertWithoutGuidesInput {
  update: UserUpdateWithoutGuidesDataInput!
  create: UserCreateWithoutGuidesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  guides_every: GuideWhereInput
  guides_some: GuideWhereInput
  guides_none: GuideWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  handle: String
  email: String
}
`
      }
    