module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBoss {
  count: Int!
}

type AggregateBossStruct {
  count: Int!
}

type AggregateClass {
  count: Int!
}

type AggregateContinent {
  count: Int!
}

type AggregateElement {
  count: Int!
}

type AggregateFood {
  count: Int!
}

type AggregateGuide {
  count: Int!
}

type AggregateMap {
  count: Int!
}

type AggregateMonsterSkill {
  count: Int!
}

type AggregatePet {
  count: Int!
}

type AggregateSkill {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Boss {
  id: ID!
  name: String!
  element_one: Element
  element_one_value: Int
  element_two: Element
  element_two_value: Int
  map_found(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map!]
  continent_found(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Continent!]
}

type BossConnection {
  pageInfo: PageInfo!
  edges: [BossEdge]!
  aggregate: AggregateBoss!
}

input BossCreateInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  map_found: MapCreateManyWithoutNative_bossInput
  continent_found: ContinentCreateManyWithoutBossesInput
}

input BossCreateManyWithoutContinent_foundInput {
  create: [BossCreateWithoutContinent_foundInput!]
  connect: [BossWhereUniqueInput!]
}

input BossCreateManyWithoutMap_foundInput {
  create: [BossCreateWithoutMap_foundInput!]
  connect: [BossWhereUniqueInput!]
}

input BossCreateOneInput {
  create: BossCreateInput
  connect: BossWhereUniqueInput
}

input BossCreateWithoutContinent_foundInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  map_found: MapCreateManyWithoutNative_bossInput
}

input BossCreateWithoutMap_foundInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  continent_found: ContinentCreateManyWithoutBossesInput
}

type BossEdge {
  node: Boss!
  cursor: String!
}

enum BossOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  element_one_value_ASC
  element_one_value_DESC
  element_two_value_ASC
  element_two_value_DESC
}

type BossPreviousValues {
  id: ID!
  name: String!
  element_one_value: Int
  element_two_value: Int
}

input BossScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  element_one_value: Int
  element_one_value_not: Int
  element_one_value_in: [Int!]
  element_one_value_not_in: [Int!]
  element_one_value_lt: Int
  element_one_value_lte: Int
  element_one_value_gt: Int
  element_one_value_gte: Int
  element_two_value: Int
  element_two_value_not: Int
  element_two_value_in: [Int!]
  element_two_value_not_in: [Int!]
  element_two_value_lt: Int
  element_two_value_lte: Int
  element_two_value_gt: Int
  element_two_value_gte: Int
  AND: [BossScalarWhereInput!]
  OR: [BossScalarWhereInput!]
  NOT: [BossScalarWhereInput!]
}

type BossStruct {
  id: ID!
  map: Map!
  boss: Boss!
  minion_present: Boolean
  AtkSpd: Float
  skills(where: MonsterSkillWhereInput, orderBy: MonsterSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MonsterSkill!]
}

type BossStructConnection {
  pageInfo: PageInfo!
  edges: [BossStructEdge]!
  aggregate: AggregateBossStruct!
}

input BossStructCreateInput {
  id: ID
  map: MapCreateOneWithoutBosses_foundInput!
  boss: BossCreateOneInput!
  minion_present: Boolean
  AtkSpd: Float
  skills: MonsterSkillCreateManyInput
}

input BossStructCreateManyWithoutMapInput {
  create: [BossStructCreateWithoutMapInput!]
  connect: [BossStructWhereUniqueInput!]
}

input BossStructCreateWithoutMapInput {
  id: ID
  boss: BossCreateOneInput!
  minion_present: Boolean
  AtkSpd: Float
  skills: MonsterSkillCreateManyInput
}

type BossStructEdge {
  node: BossStruct!
  cursor: String!
}

enum BossStructOrderByInput {
  id_ASC
  id_DESC
  minion_present_ASC
  minion_present_DESC
  AtkSpd_ASC
  AtkSpd_DESC
}

type BossStructPreviousValues {
  id: ID!
  minion_present: Boolean
  AtkSpd: Float
}

input BossStructScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  minion_present: Boolean
  minion_present_not: Boolean
  AtkSpd: Float
  AtkSpd_not: Float
  AtkSpd_in: [Float!]
  AtkSpd_not_in: [Float!]
  AtkSpd_lt: Float
  AtkSpd_lte: Float
  AtkSpd_gt: Float
  AtkSpd_gte: Float
  AND: [BossStructScalarWhereInput!]
  OR: [BossStructScalarWhereInput!]
  NOT: [BossStructScalarWhereInput!]
}

type BossStructSubscriptionPayload {
  mutation: MutationType!
  node: BossStruct
  updatedFields: [String!]
  previousValues: BossStructPreviousValues
}

input BossStructSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BossStructWhereInput
  AND: [BossStructSubscriptionWhereInput!]
  OR: [BossStructSubscriptionWhereInput!]
  NOT: [BossStructSubscriptionWhereInput!]
}

input BossStructUpdateInput {
  map: MapUpdateOneRequiredWithoutBosses_foundInput
  boss: BossUpdateOneRequiredInput
  minion_present: Boolean
  AtkSpd: Float
  skills: MonsterSkillUpdateManyInput
}

input BossStructUpdateManyDataInput {
  minion_present: Boolean
  AtkSpd: Float
}

input BossStructUpdateManyMutationInput {
  minion_present: Boolean
  AtkSpd: Float
}

input BossStructUpdateManyWithoutMapInput {
  create: [BossStructCreateWithoutMapInput!]
  delete: [BossStructWhereUniqueInput!]
  connect: [BossStructWhereUniqueInput!]
  set: [BossStructWhereUniqueInput!]
  disconnect: [BossStructWhereUniqueInput!]
  update: [BossStructUpdateWithWhereUniqueWithoutMapInput!]
  upsert: [BossStructUpsertWithWhereUniqueWithoutMapInput!]
  deleteMany: [BossStructScalarWhereInput!]
  updateMany: [BossStructUpdateManyWithWhereNestedInput!]
}

input BossStructUpdateManyWithWhereNestedInput {
  where: BossStructScalarWhereInput!
  data: BossStructUpdateManyDataInput!
}

input BossStructUpdateWithoutMapDataInput {
  boss: BossUpdateOneRequiredInput
  minion_present: Boolean
  AtkSpd: Float
  skills: MonsterSkillUpdateManyInput
}

input BossStructUpdateWithWhereUniqueWithoutMapInput {
  where: BossStructWhereUniqueInput!
  data: BossStructUpdateWithoutMapDataInput!
}

input BossStructUpsertWithWhereUniqueWithoutMapInput {
  where: BossStructWhereUniqueInput!
  update: BossStructUpdateWithoutMapDataInput!
  create: BossStructCreateWithoutMapInput!
}

input BossStructWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  map: MapWhereInput
  boss: BossWhereInput
  minion_present: Boolean
  minion_present_not: Boolean
  AtkSpd: Float
  AtkSpd_not: Float
  AtkSpd_in: [Float!]
  AtkSpd_not_in: [Float!]
  AtkSpd_lt: Float
  AtkSpd_lte: Float
  AtkSpd_gt: Float
  AtkSpd_gte: Float
  skills_every: MonsterSkillWhereInput
  skills_some: MonsterSkillWhereInput
  skills_none: MonsterSkillWhereInput
  AND: [BossStructWhereInput!]
  OR: [BossStructWhereInput!]
  NOT: [BossStructWhereInput!]
}

input BossStructWhereUniqueInput {
  id: ID
}

type BossSubscriptionPayload {
  mutation: MutationType!
  node: Boss
  updatedFields: [String!]
  previousValues: BossPreviousValues
}

input BossSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BossWhereInput
  AND: [BossSubscriptionWhereInput!]
  OR: [BossSubscriptionWhereInput!]
  NOT: [BossSubscriptionWhereInput!]
}

input BossUpdateDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  map_found: MapUpdateManyWithoutNative_bossInput
  continent_found: ContinentUpdateManyWithoutBossesInput
}

input BossUpdateInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  map_found: MapUpdateManyWithoutNative_bossInput
  continent_found: ContinentUpdateManyWithoutBossesInput
}

input BossUpdateManyDataInput {
  name: String
  element_one_value: Int
  element_two_value: Int
}

input BossUpdateManyMutationInput {
  name: String
  element_one_value: Int
  element_two_value: Int
}

input BossUpdateManyWithoutContinent_foundInput {
  create: [BossCreateWithoutContinent_foundInput!]
  delete: [BossWhereUniqueInput!]
  connect: [BossWhereUniqueInput!]
  set: [BossWhereUniqueInput!]
  disconnect: [BossWhereUniqueInput!]
  update: [BossUpdateWithWhereUniqueWithoutContinent_foundInput!]
  upsert: [BossUpsertWithWhereUniqueWithoutContinent_foundInput!]
  deleteMany: [BossScalarWhereInput!]
  updateMany: [BossUpdateManyWithWhereNestedInput!]
}

input BossUpdateManyWithoutMap_foundInput {
  create: [BossCreateWithoutMap_foundInput!]
  delete: [BossWhereUniqueInput!]
  connect: [BossWhereUniqueInput!]
  set: [BossWhereUniqueInput!]
  disconnect: [BossWhereUniqueInput!]
  update: [BossUpdateWithWhereUniqueWithoutMap_foundInput!]
  upsert: [BossUpsertWithWhereUniqueWithoutMap_foundInput!]
  deleteMany: [BossScalarWhereInput!]
  updateMany: [BossUpdateManyWithWhereNestedInput!]
}

input BossUpdateManyWithWhereNestedInput {
  where: BossScalarWhereInput!
  data: BossUpdateManyDataInput!
}

input BossUpdateOneRequiredInput {
  create: BossCreateInput
  update: BossUpdateDataInput
  upsert: BossUpsertNestedInput
  connect: BossWhereUniqueInput
}

input BossUpdateWithoutContinent_foundDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  map_found: MapUpdateManyWithoutNative_bossInput
}

input BossUpdateWithoutMap_foundDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  continent_found: ContinentUpdateManyWithoutBossesInput
}

input BossUpdateWithWhereUniqueWithoutContinent_foundInput {
  where: BossWhereUniqueInput!
  data: BossUpdateWithoutContinent_foundDataInput!
}

input BossUpdateWithWhereUniqueWithoutMap_foundInput {
  where: BossWhereUniqueInput!
  data: BossUpdateWithoutMap_foundDataInput!
}

input BossUpsertNestedInput {
  update: BossUpdateDataInput!
  create: BossCreateInput!
}

input BossUpsertWithWhereUniqueWithoutContinent_foundInput {
  where: BossWhereUniqueInput!
  update: BossUpdateWithoutContinent_foundDataInput!
  create: BossCreateWithoutContinent_foundInput!
}

input BossUpsertWithWhereUniqueWithoutMap_foundInput {
  where: BossWhereUniqueInput!
  update: BossUpdateWithoutMap_foundDataInput!
  create: BossCreateWithoutMap_foundInput!
}

input BossWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  element_one: ElementWhereInput
  element_one_value: Int
  element_one_value_not: Int
  element_one_value_in: [Int!]
  element_one_value_not_in: [Int!]
  element_one_value_lt: Int
  element_one_value_lte: Int
  element_one_value_gt: Int
  element_one_value_gte: Int
  element_two: ElementWhereInput
  element_two_value: Int
  element_two_value_not: Int
  element_two_value_in: [Int!]
  element_two_value_not_in: [Int!]
  element_two_value_lt: Int
  element_two_value_lte: Int
  element_two_value_gt: Int
  element_two_value_gte: Int
  map_found_every: MapWhereInput
  map_found_some: MapWhereInput
  map_found_none: MapWhereInput
  continent_found_every: ContinentWhereInput
  continent_found_some: ContinentWhereInput
  continent_found_none: ContinentWhereInput
  AND: [BossWhereInput!]
  OR: [BossWhereInput!]
  NOT: [BossWhereInput!]
}

input BossWhereUniqueInput {
  id: ID
  name: String
}

type Class {
  id: ID!
  name: Hero!
  description: String!
  weapon: String!
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
}

type ClassConnection {
  pageInfo: PageInfo!
  edges: [ClassEdge]!
  aggregate: AggregateClass!
}

input ClassCreateInput {
  id: ID
  name: Hero!
  description: String!
  weapon: String!
  skills: SkillCreateManyWithoutClassInput
}

input ClassCreateOneWithoutSkillsInput {
  create: ClassCreateWithoutSkillsInput
  connect: ClassWhereUniqueInput
}

input ClassCreateWithoutSkillsInput {
  id: ID
  name: Hero!
  description: String!
  weapon: String!
}

type ClassEdge {
  node: Class!
  cursor: String!
}

enum ClassOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  weapon_ASC
  weapon_DESC
}

type ClassPreviousValues {
  id: ID!
  name: Hero!
  description: String!
  weapon: String!
}

type ClassSubscriptionPayload {
  mutation: MutationType!
  node: Class
  updatedFields: [String!]
  previousValues: ClassPreviousValues
}

input ClassSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClassWhereInput
  AND: [ClassSubscriptionWhereInput!]
  OR: [ClassSubscriptionWhereInput!]
  NOT: [ClassSubscriptionWhereInput!]
}

input ClassUpdateInput {
  name: Hero
  description: String
  weapon: String
  skills: SkillUpdateManyWithoutClassInput
}

input ClassUpdateManyMutationInput {
  name: Hero
  description: String
  weapon: String
}

input ClassUpdateOneWithoutSkillsInput {
  create: ClassCreateWithoutSkillsInput
  update: ClassUpdateWithoutSkillsDataInput
  upsert: ClassUpsertWithoutSkillsInput
  delete: Boolean
  disconnect: Boolean
  connect: ClassWhereUniqueInput
}

input ClassUpdateWithoutSkillsDataInput {
  name: Hero
  description: String
  weapon: String
}

input ClassUpsertWithoutSkillsInput {
  update: ClassUpdateWithoutSkillsDataInput!
  create: ClassCreateWithoutSkillsInput!
}

input ClassWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: Hero
  name_not: Hero
  name_in: [Hero!]
  name_not_in: [Hero!]
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  weapon: String
  weapon_not: String
  weapon_in: [String!]
  weapon_not_in: [String!]
  weapon_lt: String
  weapon_lte: String
  weapon_gt: String
  weapon_gte: String
  weapon_contains: String
  weapon_not_contains: String
  weapon_starts_with: String
  weapon_not_starts_with: String
  weapon_ends_with: String
  weapon_not_ends_with: String
  skills_every: SkillWhereInput
  skills_some: SkillWhereInput
  skills_none: SkillWhereInput
  AND: [ClassWhereInput!]
  OR: [ClassWhereInput!]
  NOT: [ClassWhereInput!]
}

input ClassWhereUniqueInput {
  id: ID
  name: Hero
}

enum CombatType {
  UNKNOWN
  BUFF
  DAMAGE
  HEAL
  CONTINUOUS
  OVER_TIME
  AREA_OF_EFFECT
  TARGET
  CROWD_CONTROL
  SUMMON
  DEBUFF
  DISPELL
  RANDOM
  ABSORB
  STEALTH
  PASSIVE
}

type Continent {
  id: ID!
  name: String!
  bosses(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss!]
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map!]
  next_continent: String
  previous_continent: String
}

type ContinentConnection {
  pageInfo: PageInfo!
  edges: [ContinentEdge]!
  aggregate: AggregateContinent!
}

input ContinentCreateInput {
  id: ID
  name: String!
  bosses: BossCreateManyWithoutContinent_foundInput
  maps: MapCreateManyWithoutContinentInput
  next_continent: String
  previous_continent: String
}

input ContinentCreateManyWithoutBossesInput {
  create: [ContinentCreateWithoutBossesInput!]
  connect: [ContinentWhereUniqueInput!]
}

input ContinentCreateOneWithoutMapsInput {
  create: ContinentCreateWithoutMapsInput
  connect: ContinentWhereUniqueInput
}

input ContinentCreateWithoutBossesInput {
  id: ID
  name: String!
  maps: MapCreateManyWithoutContinentInput
  next_continent: String
  previous_continent: String
}

input ContinentCreateWithoutMapsInput {
  id: ID
  name: String!
  bosses: BossCreateManyWithoutContinent_foundInput
  next_continent: String
  previous_continent: String
}

type ContinentEdge {
  node: Continent!
  cursor: String!
}

enum ContinentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  next_continent_ASC
  next_continent_DESC
  previous_continent_ASC
  previous_continent_DESC
}

type ContinentPreviousValues {
  id: ID!
  name: String!
  next_continent: String
  previous_continent: String
}

input ContinentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  next_continent: String
  next_continent_not: String
  next_continent_in: [String!]
  next_continent_not_in: [String!]
  next_continent_lt: String
  next_continent_lte: String
  next_continent_gt: String
  next_continent_gte: String
  next_continent_contains: String
  next_continent_not_contains: String
  next_continent_starts_with: String
  next_continent_not_starts_with: String
  next_continent_ends_with: String
  next_continent_not_ends_with: String
  previous_continent: String
  previous_continent_not: String
  previous_continent_in: [String!]
  previous_continent_not_in: [String!]
  previous_continent_lt: String
  previous_continent_lte: String
  previous_continent_gt: String
  previous_continent_gte: String
  previous_continent_contains: String
  previous_continent_not_contains: String
  previous_continent_starts_with: String
  previous_continent_not_starts_with: String
  previous_continent_ends_with: String
  previous_continent_not_ends_with: String
  AND: [ContinentScalarWhereInput!]
  OR: [ContinentScalarWhereInput!]
  NOT: [ContinentScalarWhereInput!]
}

type ContinentSubscriptionPayload {
  mutation: MutationType!
  node: Continent
  updatedFields: [String!]
  previousValues: ContinentPreviousValues
}

input ContinentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContinentWhereInput
  AND: [ContinentSubscriptionWhereInput!]
  OR: [ContinentSubscriptionWhereInput!]
  NOT: [ContinentSubscriptionWhereInput!]
}

input ContinentUpdateInput {
  name: String
  bosses: BossUpdateManyWithoutContinent_foundInput
  maps: MapUpdateManyWithoutContinentInput
  next_continent: String
  previous_continent: String
}

input ContinentUpdateManyDataInput {
  name: String
  next_continent: String
  previous_continent: String
}

input ContinentUpdateManyMutationInput {
  name: String
  next_continent: String
  previous_continent: String
}

input ContinentUpdateManyWithoutBossesInput {
  create: [ContinentCreateWithoutBossesInput!]
  delete: [ContinentWhereUniqueInput!]
  connect: [ContinentWhereUniqueInput!]
  set: [ContinentWhereUniqueInput!]
  disconnect: [ContinentWhereUniqueInput!]
  update: [ContinentUpdateWithWhereUniqueWithoutBossesInput!]
  upsert: [ContinentUpsertWithWhereUniqueWithoutBossesInput!]
  deleteMany: [ContinentScalarWhereInput!]
  updateMany: [ContinentUpdateManyWithWhereNestedInput!]
}

input ContinentUpdateManyWithWhereNestedInput {
  where: ContinentScalarWhereInput!
  data: ContinentUpdateManyDataInput!
}

input ContinentUpdateOneRequiredWithoutMapsInput {
  create: ContinentCreateWithoutMapsInput
  update: ContinentUpdateWithoutMapsDataInput
  upsert: ContinentUpsertWithoutMapsInput
  connect: ContinentWhereUniqueInput
}

input ContinentUpdateWithoutBossesDataInput {
  name: String
  maps: MapUpdateManyWithoutContinentInput
  next_continent: String
  previous_continent: String
}

input ContinentUpdateWithoutMapsDataInput {
  name: String
  bosses: BossUpdateManyWithoutContinent_foundInput
  next_continent: String
  previous_continent: String
}

input ContinentUpdateWithWhereUniqueWithoutBossesInput {
  where: ContinentWhereUniqueInput!
  data: ContinentUpdateWithoutBossesDataInput!
}

input ContinentUpsertWithoutMapsInput {
  update: ContinentUpdateWithoutMapsDataInput!
  create: ContinentCreateWithoutMapsInput!
}

input ContinentUpsertWithWhereUniqueWithoutBossesInput {
  where: ContinentWhereUniqueInput!
  update: ContinentUpdateWithoutBossesDataInput!
  create: ContinentCreateWithoutBossesInput!
}

input ContinentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  bosses_every: BossWhereInput
  bosses_some: BossWhereInput
  bosses_none: BossWhereInput
  maps_every: MapWhereInput
  maps_some: MapWhereInput
  maps_none: MapWhereInput
  next_continent: String
  next_continent_not: String
  next_continent_in: [String!]
  next_continent_not_in: [String!]
  next_continent_lt: String
  next_continent_lte: String
  next_continent_gt: String
  next_continent_gte: String
  next_continent_contains: String
  next_continent_not_contains: String
  next_continent_starts_with: String
  next_continent_not_starts_with: String
  next_continent_ends_with: String
  next_continent_not_ends_with: String
  previous_continent: String
  previous_continent_not: String
  previous_continent_in: [String!]
  previous_continent_not_in: [String!]
  previous_continent_lt: String
  previous_continent_lte: String
  previous_continent_gt: String
  previous_continent_gte: String
  previous_continent_contains: String
  previous_continent_not_contains: String
  previous_continent_starts_with: String
  previous_continent_not_starts_with: String
  previous_continent_ends_with: String
  previous_continent_not_ends_with: String
  AND: [ContinentWhereInput!]
  OR: [ContinentWhereInput!]
  NOT: [ContinentWhereInput!]
}

input ContinentWhereUniqueInput {
  id: ID
  name: String
}

scalar DateTime

type Element {
  id: ID!
  name: ElementType!
  weakness: ElementType
  effective: ElementType
}

type ElementConnection {
  pageInfo: PageInfo!
  edges: [ElementEdge]!
  aggregate: AggregateElement!
}

input ElementCreateInput {
  id: ID
  name: ElementType!
  weakness: ElementType
  effective: ElementType
}

input ElementCreateOneInput {
  create: ElementCreateInput
  connect: ElementWhereUniqueInput
}

type ElementEdge {
  node: Element!
  cursor: String!
}

enum ElementOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  weakness_ASC
  weakness_DESC
  effective_ASC
  effective_DESC
}

type ElementPreviousValues {
  id: ID!
  name: ElementType!
  weakness: ElementType
  effective: ElementType
}

type ElementSubscriptionPayload {
  mutation: MutationType!
  node: Element
  updatedFields: [String!]
  previousValues: ElementPreviousValues
}

input ElementSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ElementWhereInput
  AND: [ElementSubscriptionWhereInput!]
  OR: [ElementSubscriptionWhereInput!]
  NOT: [ElementSubscriptionWhereInput!]
}

enum ElementType {
  FIRE
  LIGHTNING
  FROST
  EARTH
}

input ElementUpdateDataInput {
  name: ElementType
  weakness: ElementType
  effective: ElementType
}

input ElementUpdateInput {
  name: ElementType
  weakness: ElementType
  effective: ElementType
}

input ElementUpdateManyMutationInput {
  name: ElementType
  weakness: ElementType
  effective: ElementType
}

input ElementUpdateOneInput {
  create: ElementCreateInput
  update: ElementUpdateDataInput
  upsert: ElementUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ElementWhereUniqueInput
}

input ElementUpsertNestedInput {
  update: ElementUpdateDataInput!
  create: ElementCreateInput!
}

input ElementWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: ElementType
  name_not: ElementType
  name_in: [ElementType!]
  name_not_in: [ElementType!]
  weakness: ElementType
  weakness_not: ElementType
  weakness_in: [ElementType!]
  weakness_not_in: [ElementType!]
  effective: ElementType
  effective_not: ElementType
  effective_in: [ElementType!]
  effective_not_in: [ElementType!]
  AND: [ElementWhereInput!]
  OR: [ElementWhereInput!]
  NOT: [ElementWhereInput!]
}

input ElementWhereUniqueInput {
  id: ID
  name: ElementType
}

type Food {
  id: ID!
  name: String!
  pet_favorite(where: PetWhereInput, orderBy: PetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pet!]
  buff: Stat
  imageurl: String
}

type FoodConnection {
  pageInfo: PageInfo!
  edges: [FoodEdge]!
  aggregate: AggregateFood!
}

input FoodCreateInput {
  id: ID
  name: String!
  pet_favorite: PetCreateManyWithoutFavorite_foodInput
  buff: Stat
  imageurl: String
}

input FoodCreateOneWithoutPet_favoriteInput {
  create: FoodCreateWithoutPet_favoriteInput
  connect: FoodWhereUniqueInput
}

input FoodCreateWithoutPet_favoriteInput {
  id: ID
  name: String!
  buff: Stat
  imageurl: String
}

type FoodEdge {
  node: Food!
  cursor: String!
}

enum FoodOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  buff_ASC
  buff_DESC
  imageurl_ASC
  imageurl_DESC
}

type FoodPreviousValues {
  id: ID!
  name: String!
  buff: Stat
  imageurl: String
}

type FoodSubscriptionPayload {
  mutation: MutationType!
  node: Food
  updatedFields: [String!]
  previousValues: FoodPreviousValues
}

input FoodSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FoodWhereInput
  AND: [FoodSubscriptionWhereInput!]
  OR: [FoodSubscriptionWhereInput!]
  NOT: [FoodSubscriptionWhereInput!]
}

input FoodUpdateInput {
  name: String
  pet_favorite: PetUpdateManyWithoutFavorite_foodInput
  buff: Stat
  imageurl: String
}

input FoodUpdateManyMutationInput {
  name: String
  buff: Stat
  imageurl: String
}

input FoodUpdateOneWithoutPet_favoriteInput {
  create: FoodCreateWithoutPet_favoriteInput
  update: FoodUpdateWithoutPet_favoriteDataInput
  upsert: FoodUpsertWithoutPet_favoriteInput
  delete: Boolean
  disconnect: Boolean
  connect: FoodWhereUniqueInput
}

input FoodUpdateWithoutPet_favoriteDataInput {
  name: String
  buff: Stat
  imageurl: String
}

input FoodUpsertWithoutPet_favoriteInput {
  update: FoodUpdateWithoutPet_favoriteDataInput!
  create: FoodCreateWithoutPet_favoriteInput!
}

input FoodWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  pet_favorite_every: PetWhereInput
  pet_favorite_some: PetWhereInput
  pet_favorite_none: PetWhereInput
  buff: Stat
  buff_not: Stat
  buff_in: [Stat!]
  buff_not_in: [Stat!]
  imageurl: String
  imageurl_not: String
  imageurl_in: [String!]
  imageurl_not_in: [String!]
  imageurl_lt: String
  imageurl_lte: String
  imageurl_gt: String
  imageurl_gte: String
  imageurl_contains: String
  imageurl_not_contains: String
  imageurl_starts_with: String
  imageurl_not_starts_with: String
  imageurl_ends_with: String
  imageurl_not_ends_with: String
  AND: [FoodWhereInput!]
  OR: [FoodWhereInput!]
  NOT: [FoodWhereInput!]
}

input FoodWhereUniqueInput {
  id: ID
  name: String
}

type Guide {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  title: String!
  body: String!
  owner: User!
}

type GuideConnection {
  pageInfo: PageInfo!
  edges: [GuideEdge]!
  aggregate: AggregateGuide!
}

input GuideCreateInput {
  id: ID
  updateAt: DateTime
  title: String!
  body: String!
  owner: UserCreateOneWithoutGuidesInput!
}

input GuideCreateManyWithoutOwnerInput {
  create: [GuideCreateWithoutOwnerInput!]
  connect: [GuideWhereUniqueInput!]
}

input GuideCreateWithoutOwnerInput {
  id: ID
  updateAt: DateTime
  title: String!
  body: String!
}

type GuideEdge {
  node: Guide!
  cursor: String!
}

enum GuideOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updateAt_ASC
  updateAt_DESC
  title_ASC
  title_DESC
  body_ASC
  body_DESC
}

type GuidePreviousValues {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  title: String!
  body: String!
}

input GuideScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [GuideScalarWhereInput!]
  OR: [GuideScalarWhereInput!]
  NOT: [GuideScalarWhereInput!]
}

type GuideSubscriptionPayload {
  mutation: MutationType!
  node: Guide
  updatedFields: [String!]
  previousValues: GuidePreviousValues
}

input GuideSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuideWhereInput
  AND: [GuideSubscriptionWhereInput!]
  OR: [GuideSubscriptionWhereInput!]
  NOT: [GuideSubscriptionWhereInput!]
}

input GuideUpdateInput {
  updateAt: DateTime
  title: String
  body: String
  owner: UserUpdateOneRequiredWithoutGuidesInput
}

input GuideUpdateManyDataInput {
  updateAt: DateTime
  title: String
  body: String
}

input GuideUpdateManyMutationInput {
  updateAt: DateTime
  title: String
  body: String
}

input GuideUpdateManyWithoutOwnerInput {
  create: [GuideCreateWithoutOwnerInput!]
  delete: [GuideWhereUniqueInput!]
  connect: [GuideWhereUniqueInput!]
  set: [GuideWhereUniqueInput!]
  disconnect: [GuideWhereUniqueInput!]
  update: [GuideUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [GuideUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [GuideScalarWhereInput!]
  updateMany: [GuideUpdateManyWithWhereNestedInput!]
}

input GuideUpdateManyWithWhereNestedInput {
  where: GuideScalarWhereInput!
  data: GuideUpdateManyDataInput!
}

input GuideUpdateWithoutOwnerDataInput {
  updateAt: DateTime
  title: String
  body: String
}

input GuideUpdateWithWhereUniqueWithoutOwnerInput {
  where: GuideWhereUniqueInput!
  data: GuideUpdateWithoutOwnerDataInput!
}

input GuideUpsertWithWhereUniqueWithoutOwnerInput {
  where: GuideWhereUniqueInput!
  update: GuideUpdateWithoutOwnerDataInput!
  create: GuideCreateWithoutOwnerInput!
}

input GuideWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  owner: UserWhereInput
  AND: [GuideWhereInput!]
  OR: [GuideWhereInput!]
  NOT: [GuideWhereInput!]
}

input GuideWhereUniqueInput {
  id: ID
}

enum Hero {
  WARLOCK
  SHAMAN
  ASSASSIN
  HUNTER
  DRUID
  MAGE
  GLADIATOR
  WARRIOR
}

scalar Long

type Map {
  id: ID!
  name: String!
  total_stage: Int
  native_boss(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss!]
  obtainable_skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill!]
  bosses_found(where: BossStructWhereInput, orderBy: BossStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BossStruct!]
  previous_map: String
  next_map: String
  pet_unlock(where: PetWhereInput, orderBy: PetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pet!]
  continent: Continent!
  imageurl: String
}

type MapConnection {
  pageInfo: PageInfo!
  edges: [MapEdge]!
  aggregate: AggregateMap!
}

input MapCreateInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutMap_foundInput
  obtainable_skills: SkillCreateManyWithoutLocationInput
  bosses_found: BossStructCreateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetCreateManyWithoutAreaInput
  continent: ContinentCreateOneWithoutMapsInput!
  imageurl: String
}

input MapCreateManyWithoutContinentInput {
  create: [MapCreateWithoutContinentInput!]
  connect: [MapWhereUniqueInput!]
}

input MapCreateManyWithoutNative_bossInput {
  create: [MapCreateWithoutNative_bossInput!]
  connect: [MapWhereUniqueInput!]
}

input MapCreateOneWithoutBosses_foundInput {
  create: MapCreateWithoutBosses_foundInput
  connect: MapWhereUniqueInput
}

input MapCreateOneWithoutObtainable_skillsInput {
  create: MapCreateWithoutObtainable_skillsInput
  connect: MapWhereUniqueInput
}

input MapCreateOneWithoutPet_unlockInput {
  create: MapCreateWithoutPet_unlockInput
  connect: MapWhereUniqueInput
}

input MapCreateWithoutBosses_foundInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutMap_foundInput
  obtainable_skills: SkillCreateManyWithoutLocationInput
  previous_map: String
  next_map: String
  pet_unlock: PetCreateManyWithoutAreaInput
  continent: ContinentCreateOneWithoutMapsInput!
  imageurl: String
}

input MapCreateWithoutContinentInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutMap_foundInput
  obtainable_skills: SkillCreateManyWithoutLocationInput
  bosses_found: BossStructCreateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetCreateManyWithoutAreaInput
  imageurl: String
}

input MapCreateWithoutNative_bossInput {
  id: ID
  name: String!
  total_stage: Int
  obtainable_skills: SkillCreateManyWithoutLocationInput
  bosses_found: BossStructCreateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetCreateManyWithoutAreaInput
  continent: ContinentCreateOneWithoutMapsInput!
  imageurl: String
}

input MapCreateWithoutObtainable_skillsInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutMap_foundInput
  bosses_found: BossStructCreateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetCreateManyWithoutAreaInput
  continent: ContinentCreateOneWithoutMapsInput!
  imageurl: String
}

input MapCreateWithoutPet_unlockInput {
  id: ID
  name: String!
  total_stage: Int
  native_boss: BossCreateManyWithoutMap_foundInput
  obtainable_skills: SkillCreateManyWithoutLocationInput
  bosses_found: BossStructCreateManyWithoutMapInput
  previous_map: String
  next_map: String
  continent: ContinentCreateOneWithoutMapsInput!
  imageurl: String
}

type MapEdge {
  node: Map!
  cursor: String!
}

enum MapOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  total_stage_ASC
  total_stage_DESC
  previous_map_ASC
  previous_map_DESC
  next_map_ASC
  next_map_DESC
  imageurl_ASC
  imageurl_DESC
}

type MapPreviousValues {
  id: ID!
  name: String!
  total_stage: Int
  previous_map: String
  next_map: String
  imageurl: String
}

input MapScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  total_stage: Int
  total_stage_not: Int
  total_stage_in: [Int!]
  total_stage_not_in: [Int!]
  total_stage_lt: Int
  total_stage_lte: Int
  total_stage_gt: Int
  total_stage_gte: Int
  previous_map: String
  previous_map_not: String
  previous_map_in: [String!]
  previous_map_not_in: [String!]
  previous_map_lt: String
  previous_map_lte: String
  previous_map_gt: String
  previous_map_gte: String
  previous_map_contains: String
  previous_map_not_contains: String
  previous_map_starts_with: String
  previous_map_not_starts_with: String
  previous_map_ends_with: String
  previous_map_not_ends_with: String
  next_map: String
  next_map_not: String
  next_map_in: [String!]
  next_map_not_in: [String!]
  next_map_lt: String
  next_map_lte: String
  next_map_gt: String
  next_map_gte: String
  next_map_contains: String
  next_map_not_contains: String
  next_map_starts_with: String
  next_map_not_starts_with: String
  next_map_ends_with: String
  next_map_not_ends_with: String
  imageurl: String
  imageurl_not: String
  imageurl_in: [String!]
  imageurl_not_in: [String!]
  imageurl_lt: String
  imageurl_lte: String
  imageurl_gt: String
  imageurl_gte: String
  imageurl_contains: String
  imageurl_not_contains: String
  imageurl_starts_with: String
  imageurl_not_starts_with: String
  imageurl_ends_with: String
  imageurl_not_ends_with: String
  AND: [MapScalarWhereInput!]
  OR: [MapScalarWhereInput!]
  NOT: [MapScalarWhereInput!]
}

type MapSubscriptionPayload {
  mutation: MutationType!
  node: Map
  updatedFields: [String!]
  previousValues: MapPreviousValues
}

input MapSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MapWhereInput
  AND: [MapSubscriptionWhereInput!]
  OR: [MapSubscriptionWhereInput!]
  NOT: [MapSubscriptionWhereInput!]
}

input MapUpdateInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutMap_foundInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  bosses_found: BossStructUpdateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetUpdateManyWithoutAreaInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  imageurl: String
}

input MapUpdateManyDataInput {
  name: String
  total_stage: Int
  previous_map: String
  next_map: String
  imageurl: String
}

input MapUpdateManyMutationInput {
  name: String
  total_stage: Int
  previous_map: String
  next_map: String
  imageurl: String
}

input MapUpdateManyWithoutContinentInput {
  create: [MapCreateWithoutContinentInput!]
  delete: [MapWhereUniqueInput!]
  connect: [MapWhereUniqueInput!]
  set: [MapWhereUniqueInput!]
  disconnect: [MapWhereUniqueInput!]
  update: [MapUpdateWithWhereUniqueWithoutContinentInput!]
  upsert: [MapUpsertWithWhereUniqueWithoutContinentInput!]
  deleteMany: [MapScalarWhereInput!]
  updateMany: [MapUpdateManyWithWhereNestedInput!]
}

input MapUpdateManyWithoutNative_bossInput {
  create: [MapCreateWithoutNative_bossInput!]
  delete: [MapWhereUniqueInput!]
  connect: [MapWhereUniqueInput!]
  set: [MapWhereUniqueInput!]
  disconnect: [MapWhereUniqueInput!]
  update: [MapUpdateWithWhereUniqueWithoutNative_bossInput!]
  upsert: [MapUpsertWithWhereUniqueWithoutNative_bossInput!]
  deleteMany: [MapScalarWhereInput!]
  updateMany: [MapUpdateManyWithWhereNestedInput!]
}

input MapUpdateManyWithWhereNestedInput {
  where: MapScalarWhereInput!
  data: MapUpdateManyDataInput!
}

input MapUpdateOneRequiredWithoutBosses_foundInput {
  create: MapCreateWithoutBosses_foundInput
  update: MapUpdateWithoutBosses_foundDataInput
  upsert: MapUpsertWithoutBosses_foundInput
  connect: MapWhereUniqueInput
}

input MapUpdateOneWithoutObtainable_skillsInput {
  create: MapCreateWithoutObtainable_skillsInput
  update: MapUpdateWithoutObtainable_skillsDataInput
  upsert: MapUpsertWithoutObtainable_skillsInput
  delete: Boolean
  disconnect: Boolean
  connect: MapWhereUniqueInput
}

input MapUpdateOneWithoutPet_unlockInput {
  create: MapCreateWithoutPet_unlockInput
  update: MapUpdateWithoutPet_unlockDataInput
  upsert: MapUpsertWithoutPet_unlockInput
  delete: Boolean
  disconnect: Boolean
  connect: MapWhereUniqueInput
}

input MapUpdateWithoutBosses_foundDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutMap_foundInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  previous_map: String
  next_map: String
  pet_unlock: PetUpdateManyWithoutAreaInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  imageurl: String
}

input MapUpdateWithoutContinentDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutMap_foundInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  bosses_found: BossStructUpdateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetUpdateManyWithoutAreaInput
  imageurl: String
}

input MapUpdateWithoutNative_bossDataInput {
  name: String
  total_stage: Int
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  bosses_found: BossStructUpdateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetUpdateManyWithoutAreaInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  imageurl: String
}

input MapUpdateWithoutObtainable_skillsDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutMap_foundInput
  bosses_found: BossStructUpdateManyWithoutMapInput
  previous_map: String
  next_map: String
  pet_unlock: PetUpdateManyWithoutAreaInput
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  imageurl: String
}

input MapUpdateWithoutPet_unlockDataInput {
  name: String
  total_stage: Int
  native_boss: BossUpdateManyWithoutMap_foundInput
  obtainable_skills: SkillUpdateManyWithoutLocationInput
  bosses_found: BossStructUpdateManyWithoutMapInput
  previous_map: String
  next_map: String
  continent: ContinentUpdateOneRequiredWithoutMapsInput
  imageurl: String
}

input MapUpdateWithWhereUniqueWithoutContinentInput {
  where: MapWhereUniqueInput!
  data: MapUpdateWithoutContinentDataInput!
}

input MapUpdateWithWhereUniqueWithoutNative_bossInput {
  where: MapWhereUniqueInput!
  data: MapUpdateWithoutNative_bossDataInput!
}

input MapUpsertWithoutBosses_foundInput {
  update: MapUpdateWithoutBosses_foundDataInput!
  create: MapCreateWithoutBosses_foundInput!
}

input MapUpsertWithoutObtainable_skillsInput {
  update: MapUpdateWithoutObtainable_skillsDataInput!
  create: MapCreateWithoutObtainable_skillsInput!
}

input MapUpsertWithoutPet_unlockInput {
  update: MapUpdateWithoutPet_unlockDataInput!
  create: MapCreateWithoutPet_unlockInput!
}

input MapUpsertWithWhereUniqueWithoutContinentInput {
  where: MapWhereUniqueInput!
  update: MapUpdateWithoutContinentDataInput!
  create: MapCreateWithoutContinentInput!
}

input MapUpsertWithWhereUniqueWithoutNative_bossInput {
  where: MapWhereUniqueInput!
  update: MapUpdateWithoutNative_bossDataInput!
  create: MapCreateWithoutNative_bossInput!
}

input MapWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  total_stage: Int
  total_stage_not: Int
  total_stage_in: [Int!]
  total_stage_not_in: [Int!]
  total_stage_lt: Int
  total_stage_lte: Int
  total_stage_gt: Int
  total_stage_gte: Int
  native_boss_every: BossWhereInput
  native_boss_some: BossWhereInput
  native_boss_none: BossWhereInput
  obtainable_skills_every: SkillWhereInput
  obtainable_skills_some: SkillWhereInput
  obtainable_skills_none: SkillWhereInput
  bosses_found_every: BossStructWhereInput
  bosses_found_some: BossStructWhereInput
  bosses_found_none: BossStructWhereInput
  previous_map: String
  previous_map_not: String
  previous_map_in: [String!]
  previous_map_not_in: [String!]
  previous_map_lt: String
  previous_map_lte: String
  previous_map_gt: String
  previous_map_gte: String
  previous_map_contains: String
  previous_map_not_contains: String
  previous_map_starts_with: String
  previous_map_not_starts_with: String
  previous_map_ends_with: String
  previous_map_not_ends_with: String
  next_map: String
  next_map_not: String
  next_map_in: [String!]
  next_map_not_in: [String!]
  next_map_lt: String
  next_map_lte: String
  next_map_gt: String
  next_map_gte: String
  next_map_contains: String
  next_map_not_contains: String
  next_map_starts_with: String
  next_map_not_starts_with: String
  next_map_ends_with: String
  next_map_not_ends_with: String
  pet_unlock_every: PetWhereInput
  pet_unlock_some: PetWhereInput
  pet_unlock_none: PetWhereInput
  continent: ContinentWhereInput
  imageurl: String
  imageurl_not: String
  imageurl_in: [String!]
  imageurl_not_in: [String!]
  imageurl_lt: String
  imageurl_lte: String
  imageurl_gt: String
  imageurl_gte: String
  imageurl_contains: String
  imageurl_not_contains: String
  imageurl_starts_with: String
  imageurl_not_starts_with: String
  imageurl_ends_with: String
  imageurl_not_ends_with: String
  AND: [MapWhereInput!]
  OR: [MapWhereInput!]
  NOT: [MapWhereInput!]
}

input MapWhereUniqueInput {
  id: ID
  name: String
}

type MonsterSkill {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  combat_type: [CombatType!]!
  energy: Int
}

type MonsterSkillConnection {
  pageInfo: PageInfo!
  edges: [MonsterSkillEdge]!
  aggregate: AggregateMonsterSkill!
}

input MonsterSkillCreatecombat_typeInput {
  set: [CombatType!]
}

input MonsterSkillCreateInput {
  id: ID
  name: String!
  description: String!
  skill_type: MonsterSkillCreateskill_typeInput
  combat_type: MonsterSkillCreatecombat_typeInput
  energy: Int
}

input MonsterSkillCreateManyInput {
  create: [MonsterSkillCreateInput!]
  connect: [MonsterSkillWhereUniqueInput!]
}

input MonsterSkillCreateskill_typeInput {
  set: [SkillType!]
}

type MonsterSkillEdge {
  node: MonsterSkill!
  cursor: String!
}

enum MonsterSkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  energy_ASC
  energy_DESC
}

type MonsterSkillPreviousValues {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  combat_type: [CombatType!]!
  energy: Int
}

input MonsterSkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  AND: [MonsterSkillScalarWhereInput!]
  OR: [MonsterSkillScalarWhereInput!]
  NOT: [MonsterSkillScalarWhereInput!]
}

type MonsterSkillSubscriptionPayload {
  mutation: MutationType!
  node: MonsterSkill
  updatedFields: [String!]
  previousValues: MonsterSkillPreviousValues
}

input MonsterSkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MonsterSkillWhereInput
  AND: [MonsterSkillSubscriptionWhereInput!]
  OR: [MonsterSkillSubscriptionWhereInput!]
  NOT: [MonsterSkillSubscriptionWhereInput!]
}

input MonsterSkillUpdatecombat_typeInput {
  set: [CombatType!]
}

input MonsterSkillUpdateDataInput {
  name: String
  description: String
  skill_type: MonsterSkillUpdateskill_typeInput
  combat_type: MonsterSkillUpdatecombat_typeInput
  energy: Int
}

input MonsterSkillUpdateInput {
  name: String
  description: String
  skill_type: MonsterSkillUpdateskill_typeInput
  combat_type: MonsterSkillUpdatecombat_typeInput
  energy: Int
}

input MonsterSkillUpdateManyDataInput {
  name: String
  description: String
  skill_type: MonsterSkillUpdateskill_typeInput
  combat_type: MonsterSkillUpdatecombat_typeInput
  energy: Int
}

input MonsterSkillUpdateManyInput {
  create: [MonsterSkillCreateInput!]
  update: [MonsterSkillUpdateWithWhereUniqueNestedInput!]
  upsert: [MonsterSkillUpsertWithWhereUniqueNestedInput!]
  delete: [MonsterSkillWhereUniqueInput!]
  connect: [MonsterSkillWhereUniqueInput!]
  set: [MonsterSkillWhereUniqueInput!]
  disconnect: [MonsterSkillWhereUniqueInput!]
  deleteMany: [MonsterSkillScalarWhereInput!]
  updateMany: [MonsterSkillUpdateManyWithWhereNestedInput!]
}

input MonsterSkillUpdateManyMutationInput {
  name: String
  description: String
  skill_type: MonsterSkillUpdateskill_typeInput
  combat_type: MonsterSkillUpdatecombat_typeInput
  energy: Int
}

input MonsterSkillUpdateManyWithWhereNestedInput {
  where: MonsterSkillScalarWhereInput!
  data: MonsterSkillUpdateManyDataInput!
}

input MonsterSkillUpdateskill_typeInput {
  set: [SkillType!]
}

input MonsterSkillUpdateWithWhereUniqueNestedInput {
  where: MonsterSkillWhereUniqueInput!
  data: MonsterSkillUpdateDataInput!
}

input MonsterSkillUpsertWithWhereUniqueNestedInput {
  where: MonsterSkillWhereUniqueInput!
  update: MonsterSkillUpdateDataInput!
  create: MonsterSkillCreateInput!
}

input MonsterSkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  AND: [MonsterSkillWhereInput!]
  OR: [MonsterSkillWhereInput!]
  NOT: [MonsterSkillWhereInput!]
}

input MonsterSkillWhereUniqueInput {
  id: ID
  name: String
}

type Mutation {
  createBoss(data: BossCreateInput!): Boss!
  updateBoss(data: BossUpdateInput!, where: BossWhereUniqueInput!): Boss
  updateManyBosses(data: BossUpdateManyMutationInput!, where: BossWhereInput): BatchPayload!
  upsertBoss(where: BossWhereUniqueInput!, create: BossCreateInput!, update: BossUpdateInput!): Boss!
  deleteBoss(where: BossWhereUniqueInput!): Boss
  deleteManyBosses(where: BossWhereInput): BatchPayload!
  createBossStruct(data: BossStructCreateInput!): BossStruct!
  updateBossStruct(data: BossStructUpdateInput!, where: BossStructWhereUniqueInput!): BossStruct
  updateManyBossStructs(data: BossStructUpdateManyMutationInput!, where: BossStructWhereInput): BatchPayload!
  upsertBossStruct(where: BossStructWhereUniqueInput!, create: BossStructCreateInput!, update: BossStructUpdateInput!): BossStruct!
  deleteBossStruct(where: BossStructWhereUniqueInput!): BossStruct
  deleteManyBossStructs(where: BossStructWhereInput): BatchPayload!
  createClass(data: ClassCreateInput!): Class!
  updateClass(data: ClassUpdateInput!, where: ClassWhereUniqueInput!): Class
  updateManyClasses(data: ClassUpdateManyMutationInput!, where: ClassWhereInput): BatchPayload!
  upsertClass(where: ClassWhereUniqueInput!, create: ClassCreateInput!, update: ClassUpdateInput!): Class!
  deleteClass(where: ClassWhereUniqueInput!): Class
  deleteManyClasses(where: ClassWhereInput): BatchPayload!
  createContinent(data: ContinentCreateInput!): Continent!
  updateContinent(data: ContinentUpdateInput!, where: ContinentWhereUniqueInput!): Continent
  updateManyContinents(data: ContinentUpdateManyMutationInput!, where: ContinentWhereInput): BatchPayload!
  upsertContinent(where: ContinentWhereUniqueInput!, create: ContinentCreateInput!, update: ContinentUpdateInput!): Continent!
  deleteContinent(where: ContinentWhereUniqueInput!): Continent
  deleteManyContinents(where: ContinentWhereInput): BatchPayload!
  createElement(data: ElementCreateInput!): Element!
  updateElement(data: ElementUpdateInput!, where: ElementWhereUniqueInput!): Element
  updateManyElements(data: ElementUpdateManyMutationInput!, where: ElementWhereInput): BatchPayload!
  upsertElement(where: ElementWhereUniqueInput!, create: ElementCreateInput!, update: ElementUpdateInput!): Element!
  deleteElement(where: ElementWhereUniqueInput!): Element
  deleteManyElements(where: ElementWhereInput): BatchPayload!
  createFood(data: FoodCreateInput!): Food!
  updateFood(data: FoodUpdateInput!, where: FoodWhereUniqueInput!): Food
  updateManyFoods(data: FoodUpdateManyMutationInput!, where: FoodWhereInput): BatchPayload!
  upsertFood(where: FoodWhereUniqueInput!, create: FoodCreateInput!, update: FoodUpdateInput!): Food!
  deleteFood(where: FoodWhereUniqueInput!): Food
  deleteManyFoods(where: FoodWhereInput): BatchPayload!
  createGuide(data: GuideCreateInput!): Guide!
  updateGuide(data: GuideUpdateInput!, where: GuideWhereUniqueInput!): Guide
  updateManyGuides(data: GuideUpdateManyMutationInput!, where: GuideWhereInput): BatchPayload!
  upsertGuide(where: GuideWhereUniqueInput!, create: GuideCreateInput!, update: GuideUpdateInput!): Guide!
  deleteGuide(where: GuideWhereUniqueInput!): Guide
  deleteManyGuides(where: GuideWhereInput): BatchPayload!
  createMap(data: MapCreateInput!): Map!
  updateMap(data: MapUpdateInput!, where: MapWhereUniqueInput!): Map
  updateManyMaps(data: MapUpdateManyMutationInput!, where: MapWhereInput): BatchPayload!
  upsertMap(where: MapWhereUniqueInput!, create: MapCreateInput!, update: MapUpdateInput!): Map!
  deleteMap(where: MapWhereUniqueInput!): Map
  deleteManyMaps(where: MapWhereInput): BatchPayload!
  createMonsterSkill(data: MonsterSkillCreateInput!): MonsterSkill!
  updateMonsterSkill(data: MonsterSkillUpdateInput!, where: MonsterSkillWhereUniqueInput!): MonsterSkill
  updateManyMonsterSkills(data: MonsterSkillUpdateManyMutationInput!, where: MonsterSkillWhereInput): BatchPayload!
  upsertMonsterSkill(where: MonsterSkillWhereUniqueInput!, create: MonsterSkillCreateInput!, update: MonsterSkillUpdateInput!): MonsterSkill!
  deleteMonsterSkill(where: MonsterSkillWhereUniqueInput!): MonsterSkill
  deleteManyMonsterSkills(where: MonsterSkillWhereInput): BatchPayload!
  createPet(data: PetCreateInput!): Pet!
  updatePet(data: PetUpdateInput!, where: PetWhereUniqueInput!): Pet
  updateManyPets(data: PetUpdateManyMutationInput!, where: PetWhereInput): BatchPayload!
  upsertPet(where: PetWhereUniqueInput!, create: PetCreateInput!, update: PetUpdateInput!): Pet!
  deletePet(where: PetWhereUniqueInput!): Pet
  deleteManyPets(where: PetWhereInput): BatchPayload!
  createSkill(data: SkillCreateInput!): Skill!
  updateSkill(data: SkillUpdateInput!, where: SkillWhereUniqueInput!): Skill
  updateManySkills(data: SkillUpdateManyMutationInput!, where: SkillWhereInput): BatchPayload!
  upsertSkill(where: SkillWhereUniqueInput!, create: SkillCreateInput!, update: SkillUpdateInput!): Skill!
  deleteSkill(where: SkillWhereUniqueInput!): Skill
  deleteManySkills(where: SkillWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pet {
  id: ID!
  name: String!
  element_one: Element
  element_one_value: Int
  element_two: Element
  element_two_value: Int
  talent_cap: Float
  type: PetType
  favorite_food: Food
  area: Map
  imageurl: String
}

type PetConnection {
  pageInfo: PageInfo!
  edges: [PetEdge]!
  aggregate: AggregatePet!
}

input PetCreateInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  talent_cap: Float
  type: PetType
  favorite_food: FoodCreateOneWithoutPet_favoriteInput
  area: MapCreateOneWithoutPet_unlockInput
  imageurl: String
}

input PetCreateManyWithoutAreaInput {
  create: [PetCreateWithoutAreaInput!]
  connect: [PetWhereUniqueInput!]
}

input PetCreateManyWithoutFavorite_foodInput {
  create: [PetCreateWithoutFavorite_foodInput!]
  connect: [PetWhereUniqueInput!]
}

input PetCreateWithoutAreaInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  talent_cap: Float
  type: PetType
  favorite_food: FoodCreateOneWithoutPet_favoriteInput
  imageurl: String
}

input PetCreateWithoutFavorite_foodInput {
  id: ID
  name: String!
  element_one: ElementCreateOneInput
  element_one_value: Int
  element_two: ElementCreateOneInput
  element_two_value: Int
  talent_cap: Float
  type: PetType
  area: MapCreateOneWithoutPet_unlockInput
  imageurl: String
}

type PetEdge {
  node: Pet!
  cursor: String!
}

enum PetOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  element_one_value_ASC
  element_one_value_DESC
  element_two_value_ASC
  element_two_value_DESC
  talent_cap_ASC
  talent_cap_DESC
  type_ASC
  type_DESC
  imageurl_ASC
  imageurl_DESC
}

type PetPreviousValues {
  id: ID!
  name: String!
  element_one_value: Int
  element_two_value: Int
  talent_cap: Float
  type: PetType
  imageurl: String
}

input PetScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  element_one_value: Int
  element_one_value_not: Int
  element_one_value_in: [Int!]
  element_one_value_not_in: [Int!]
  element_one_value_lt: Int
  element_one_value_lte: Int
  element_one_value_gt: Int
  element_one_value_gte: Int
  element_two_value: Int
  element_two_value_not: Int
  element_two_value_in: [Int!]
  element_two_value_not_in: [Int!]
  element_two_value_lt: Int
  element_two_value_lte: Int
  element_two_value_gt: Int
  element_two_value_gte: Int
  talent_cap: Float
  talent_cap_not: Float
  talent_cap_in: [Float!]
  talent_cap_not_in: [Float!]
  talent_cap_lt: Float
  talent_cap_lte: Float
  talent_cap_gt: Float
  talent_cap_gte: Float
  type: PetType
  type_not: PetType
  type_in: [PetType!]
  type_not_in: [PetType!]
  imageurl: String
  imageurl_not: String
  imageurl_in: [String!]
  imageurl_not_in: [String!]
  imageurl_lt: String
  imageurl_lte: String
  imageurl_gt: String
  imageurl_gte: String
  imageurl_contains: String
  imageurl_not_contains: String
  imageurl_starts_with: String
  imageurl_not_starts_with: String
  imageurl_ends_with: String
  imageurl_not_ends_with: String
  AND: [PetScalarWhereInput!]
  OR: [PetScalarWhereInput!]
  NOT: [PetScalarWhereInput!]
}

type PetSubscriptionPayload {
  mutation: MutationType!
  node: Pet
  updatedFields: [String!]
  previousValues: PetPreviousValues
}

input PetSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PetWhereInput
  AND: [PetSubscriptionWhereInput!]
  OR: [PetSubscriptionWhereInput!]
  NOT: [PetSubscriptionWhereInput!]
}

enum PetType {
  ASSIST
  SYMBIOSIS
  ATTACK
  GUARDIAN
}

input PetUpdateInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  talent_cap: Float
  type: PetType
  favorite_food: FoodUpdateOneWithoutPet_favoriteInput
  area: MapUpdateOneWithoutPet_unlockInput
  imageurl: String
}

input PetUpdateManyDataInput {
  name: String
  element_one_value: Int
  element_two_value: Int
  talent_cap: Float
  type: PetType
  imageurl: String
}

input PetUpdateManyMutationInput {
  name: String
  element_one_value: Int
  element_two_value: Int
  talent_cap: Float
  type: PetType
  imageurl: String
}

input PetUpdateManyWithoutAreaInput {
  create: [PetCreateWithoutAreaInput!]
  delete: [PetWhereUniqueInput!]
  connect: [PetWhereUniqueInput!]
  set: [PetWhereUniqueInput!]
  disconnect: [PetWhereUniqueInput!]
  update: [PetUpdateWithWhereUniqueWithoutAreaInput!]
  upsert: [PetUpsertWithWhereUniqueWithoutAreaInput!]
  deleteMany: [PetScalarWhereInput!]
  updateMany: [PetUpdateManyWithWhereNestedInput!]
}

input PetUpdateManyWithoutFavorite_foodInput {
  create: [PetCreateWithoutFavorite_foodInput!]
  delete: [PetWhereUniqueInput!]
  connect: [PetWhereUniqueInput!]
  set: [PetWhereUniqueInput!]
  disconnect: [PetWhereUniqueInput!]
  update: [PetUpdateWithWhereUniqueWithoutFavorite_foodInput!]
  upsert: [PetUpsertWithWhereUniqueWithoutFavorite_foodInput!]
  deleteMany: [PetScalarWhereInput!]
  updateMany: [PetUpdateManyWithWhereNestedInput!]
}

input PetUpdateManyWithWhereNestedInput {
  where: PetScalarWhereInput!
  data: PetUpdateManyDataInput!
}

input PetUpdateWithoutAreaDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  talent_cap: Float
  type: PetType
  favorite_food: FoodUpdateOneWithoutPet_favoriteInput
  imageurl: String
}

input PetUpdateWithoutFavorite_foodDataInput {
  name: String
  element_one: ElementUpdateOneInput
  element_one_value: Int
  element_two: ElementUpdateOneInput
  element_two_value: Int
  talent_cap: Float
  type: PetType
  area: MapUpdateOneWithoutPet_unlockInput
  imageurl: String
}

input PetUpdateWithWhereUniqueWithoutAreaInput {
  where: PetWhereUniqueInput!
  data: PetUpdateWithoutAreaDataInput!
}

input PetUpdateWithWhereUniqueWithoutFavorite_foodInput {
  where: PetWhereUniqueInput!
  data: PetUpdateWithoutFavorite_foodDataInput!
}

input PetUpsertWithWhereUniqueWithoutAreaInput {
  where: PetWhereUniqueInput!
  update: PetUpdateWithoutAreaDataInput!
  create: PetCreateWithoutAreaInput!
}

input PetUpsertWithWhereUniqueWithoutFavorite_foodInput {
  where: PetWhereUniqueInput!
  update: PetUpdateWithoutFavorite_foodDataInput!
  create: PetCreateWithoutFavorite_foodInput!
}

input PetWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  element_one: ElementWhereInput
  element_one_value: Int
  element_one_value_not: Int
  element_one_value_in: [Int!]
  element_one_value_not_in: [Int!]
  element_one_value_lt: Int
  element_one_value_lte: Int
  element_one_value_gt: Int
  element_one_value_gte: Int
  element_two: ElementWhereInput
  element_two_value: Int
  element_two_value_not: Int
  element_two_value_in: [Int!]
  element_two_value_not_in: [Int!]
  element_two_value_lt: Int
  element_two_value_lte: Int
  element_two_value_gt: Int
  element_two_value_gte: Int
  talent_cap: Float
  talent_cap_not: Float
  talent_cap_in: [Float!]
  talent_cap_not_in: [Float!]
  talent_cap_lt: Float
  talent_cap_lte: Float
  talent_cap_gt: Float
  talent_cap_gte: Float
  type: PetType
  type_not: PetType
  type_in: [PetType!]
  type_not_in: [PetType!]
  favorite_food: FoodWhereInput
  area: MapWhereInput
  imageurl: String
  imageurl_not: String
  imageurl_in: [String!]
  imageurl_not_in: [String!]
  imageurl_lt: String
  imageurl_lte: String
  imageurl_gt: String
  imageurl_gte: String
  imageurl_contains: String
  imageurl_not_contains: String
  imageurl_starts_with: String
  imageurl_not_starts_with: String
  imageurl_ends_with: String
  imageurl_not_ends_with: String
  AND: [PetWhereInput!]
  OR: [PetWhereInput!]
  NOT: [PetWhereInput!]
}

input PetWhereUniqueInput {
  id: ID
  name: String
}

type Query {
  boss(where: BossWhereUniqueInput!): Boss
  bosses(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boss]!
  bossesConnection(where: BossWhereInput, orderBy: BossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BossConnection!
  bossStruct(where: BossStructWhereUniqueInput!): BossStruct
  bossStructs(where: BossStructWhereInput, orderBy: BossStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [BossStruct]!
  bossStructsConnection(where: BossStructWhereInput, orderBy: BossStructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BossStructConnection!
  class(where: ClassWhereUniqueInput!): Class
  classes(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Class]!
  classesConnection(where: ClassWhereInput, orderBy: ClassOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClassConnection!
  continent(where: ContinentWhereUniqueInput!): Continent
  continents(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Continent]!
  continentsConnection(where: ContinentWhereInput, orderBy: ContinentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContinentConnection!
  element(where: ElementWhereUniqueInput!): Element
  elements(where: ElementWhereInput, orderBy: ElementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Element]!
  elementsConnection(where: ElementWhereInput, orderBy: ElementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ElementConnection!
  food(where: FoodWhereUniqueInput!): Food
  foods(where: FoodWhereInput, orderBy: FoodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Food]!
  foodsConnection(where: FoodWhereInput, orderBy: FoodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FoodConnection!
  guide(where: GuideWhereUniqueInput!): Guide
  guides(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guide]!
  guidesConnection(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuideConnection!
  map(where: MapWhereUniqueInput!): Map
  maps(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Map]!
  mapsConnection(where: MapWhereInput, orderBy: MapOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MapConnection!
  monsterSkill(where: MonsterSkillWhereUniqueInput!): MonsterSkill
  monsterSkills(where: MonsterSkillWhereInput, orderBy: MonsterSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MonsterSkill]!
  monsterSkillsConnection(where: MonsterSkillWhereInput, orderBy: MonsterSkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MonsterSkillConnection!
  pet(where: PetWhereUniqueInput!): Pet
  pets(where: PetWhereInput, orderBy: PetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pet]!
  petsConnection(where: PetWhereInput, orderBy: PetOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PetConnection!
  skill(where: SkillWhereUniqueInput!): Skill
  skills(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skill]!
  skillsConnection(where: SkillWhereInput, orderBy: SkillOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SkillConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  ADMIN
  MODERATOR
  USER
}

type Skill {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  combat_type: [CombatType!]!
  energy: Int!
  location: Map
  class: Class
}

type SkillConnection {
  pageInfo: PageInfo!
  edges: [SkillEdge]!
  aggregate: AggregateSkill!
}

input SkillCreatecombat_typeInput {
  set: [CombatType!]
}

input SkillCreateInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  combat_type: SkillCreatecombat_typeInput
  energy: Int
  location: MapCreateOneWithoutObtainable_skillsInput
  class: ClassCreateOneWithoutSkillsInput
}

input SkillCreateManyWithoutClassInput {
  create: [SkillCreateWithoutClassInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateManyWithoutLocationInput {
  create: [SkillCreateWithoutLocationInput!]
  connect: [SkillWhereUniqueInput!]
}

input SkillCreateskill_typeInput {
  set: [SkillType!]
}

input SkillCreateWithoutClassInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  combat_type: SkillCreatecombat_typeInput
  energy: Int
  location: MapCreateOneWithoutObtainable_skillsInput
}

input SkillCreateWithoutLocationInput {
  id: ID
  name: String!
  description: String!
  skill_type: SkillCreateskill_typeInput
  combat_type: SkillCreatecombat_typeInput
  energy: Int
  class: ClassCreateOneWithoutSkillsInput
}

type SkillEdge {
  node: Skill!
  cursor: String!
}

enum SkillOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  energy_ASC
  energy_DESC
}

type SkillPreviousValues {
  id: ID!
  name: String!
  description: String!
  skill_type: [SkillType!]!
  combat_type: [CombatType!]!
  energy: Int!
}

input SkillScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  AND: [SkillScalarWhereInput!]
  OR: [SkillScalarWhereInput!]
  NOT: [SkillScalarWhereInput!]
}

type SkillSubscriptionPayload {
  mutation: MutationType!
  node: Skill
  updatedFields: [String!]
  previousValues: SkillPreviousValues
}

input SkillSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SkillWhereInput
  AND: [SkillSubscriptionWhereInput!]
  OR: [SkillSubscriptionWhereInput!]
  NOT: [SkillSubscriptionWhereInput!]
}

enum SkillType {
  UNKNOWN
  ACTIVE
  PASSIVE
}

input SkillUpdatecombat_typeInput {
  set: [CombatType!]
}

input SkillUpdateInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
  location: MapUpdateOneWithoutObtainable_skillsInput
  class: ClassUpdateOneWithoutSkillsInput
}

input SkillUpdateManyDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
}

input SkillUpdateManyMutationInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
}

input SkillUpdateManyWithoutClassInput {
  create: [SkillCreateWithoutClassInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutClassInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutClassInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyWithoutLocationInput {
  create: [SkillCreateWithoutLocationInput!]
  delete: [SkillWhereUniqueInput!]
  connect: [SkillWhereUniqueInput!]
  set: [SkillWhereUniqueInput!]
  disconnect: [SkillWhereUniqueInput!]
  update: [SkillUpdateWithWhereUniqueWithoutLocationInput!]
  upsert: [SkillUpsertWithWhereUniqueWithoutLocationInput!]
  deleteMany: [SkillScalarWhereInput!]
  updateMany: [SkillUpdateManyWithWhereNestedInput!]
}

input SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput!
  data: SkillUpdateManyDataInput!
}

input SkillUpdateskill_typeInput {
  set: [SkillType!]
}

input SkillUpdateWithoutClassDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
  location: MapUpdateOneWithoutObtainable_skillsInput
}

input SkillUpdateWithoutLocationDataInput {
  name: String
  description: String
  skill_type: SkillUpdateskill_typeInput
  combat_type: SkillUpdatecombat_typeInput
  energy: Int
  class: ClassUpdateOneWithoutSkillsInput
}

input SkillUpdateWithWhereUniqueWithoutClassInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateWithoutClassDataInput!
}

input SkillUpdateWithWhereUniqueWithoutLocationInput {
  where: SkillWhereUniqueInput!
  data: SkillUpdateWithoutLocationDataInput!
}

input SkillUpsertWithWhereUniqueWithoutClassInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateWithoutClassDataInput!
  create: SkillCreateWithoutClassInput!
}

input SkillUpsertWithWhereUniqueWithoutLocationInput {
  where: SkillWhereUniqueInput!
  update: SkillUpdateWithoutLocationDataInput!
  create: SkillCreateWithoutLocationInput!
}

input SkillWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  energy: Int
  energy_not: Int
  energy_in: [Int!]
  energy_not_in: [Int!]
  energy_lt: Int
  energy_lte: Int
  energy_gt: Int
  energy_gte: Int
  location: MapWhereInput
  class: ClassWhereInput
  AND: [SkillWhereInput!]
  OR: [SkillWhereInput!]
  NOT: [SkillWhereInput!]
}

input SkillWhereUniqueInput {
  id: ID
  name: String
}

enum Stat {
  ATTACK
  HP
  ARMOR
  ATK_SPD
  HIT
  EVASION
  CRIT
  TENACITY
  BLOCK
  IMPALE
}

type Subscription {
  boss(where: BossSubscriptionWhereInput): BossSubscriptionPayload
  bossStruct(where: BossStructSubscriptionWhereInput): BossStructSubscriptionPayload
  class(where: ClassSubscriptionWhereInput): ClassSubscriptionPayload
  continent(where: ContinentSubscriptionWhereInput): ContinentSubscriptionPayload
  element(where: ElementSubscriptionWhereInput): ElementSubscriptionPayload
  food(where: FoodSubscriptionWhereInput): FoodSubscriptionPayload
  guide(where: GuideSubscriptionWhereInput): GuideSubscriptionPayload
  map(where: MapSubscriptionWhereInput): MapSubscriptionPayload
  monsterSkill(where: MonsterSkillSubscriptionWhereInput): MonsterSkillSubscriptionPayload
  pet(where: PetSubscriptionWhereInput): PetSubscriptionPayload
  skill(where: SkillSubscriptionWhereInput): SkillSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role!
  password: String!
  guides(where: GuideWhereInput, orderBy: GuideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guide!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role
  password: String!
  guides: GuideCreateManyWithoutOwnerInput
}

input UserCreateOneWithoutGuidesInput {
  create: UserCreateWithoutGuidesInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutGuidesInput {
  id: ID
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role
  password: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updateAt_ASC
  updateAt_DESC
  handle_ASC
  handle_DESC
  email_ASC
  email_DESC
  role_ASC
  role_DESC
  password_ASC
  password_DESC
}

type UserPreviousValues {
  id: ID!
  createdAt: DateTime!
  updateAt: DateTime
  handle: String!
  email: String!
  role: Role!
  password: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  updateAt: DateTime
  handle: String
  email: String
  role: Role
  password: String
  guides: GuideUpdateManyWithoutOwnerInput
}

input UserUpdateManyMutationInput {
  updateAt: DateTime
  handle: String
  email: String
  role: Role
  password: String
}

input UserUpdateOneRequiredWithoutGuidesInput {
  create: UserCreateWithoutGuidesInput
  update: UserUpdateWithoutGuidesDataInput
  upsert: UserUpsertWithoutGuidesInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutGuidesDataInput {
  updateAt: DateTime
  handle: String
  email: String
  role: Role
  password: String
}

input UserUpsertWithoutGuidesInput {
  update: UserUpdateWithoutGuidesDataInput!
  create: UserCreateWithoutGuidesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updateAt: DateTime
  updateAt_not: DateTime
  updateAt_in: [DateTime!]
  updateAt_not_in: [DateTime!]
  updateAt_lt: DateTime
  updateAt_lte: DateTime
  updateAt_gt: DateTime
  updateAt_gte: DateTime
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  guides_every: GuideWhereInput
  guides_some: GuideWhereInput
  guides_none: GuideWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  handle: String
  email: String
}
`
      }
    